[
  {
    "question": "CUDA中矩阵乘法算子如何利用共享内存减少全局内存访问？",
    "reference": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "prediction": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构中SM的资源分配如何限制矩阵乘法算子的并行度？",
    "reference": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "prediction": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过线程索引映射实现1D输入的元素访问？",
    "reference": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "prediction": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp divergence为何会影响卷积算子的边界处理性能？",
    "reference": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "prediction": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子基于CSR格式时，线程如何映射到矩阵非零元素？",
    "reference": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "prediction": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的全局内存合并访问对SpMV算子性能有何影响？",
    "reference": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，提升内存访问效率，进而提升SpMV算子吞吐量。",
    "prediction": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，减少内存事务数量，提升带宽利用率，进而提升SpMV算子吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积神经网络卷积层算子中，如何使用常量内存存储卷积核？",
    "reference": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "prediction": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何影响tiled矩阵乘法性能？",
    "reference": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "prediction": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子如何处理边界的“幽灵细胞”？",
    "reference": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "prediction": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存对稀疏矩阵向量乘法（SpMV）有何优化作用？",
    "reference": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "prediction": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过线程块维度设置提升并行效率？",
    "reference": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "prediction": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，线程块的TILE_SIZE选择需考虑哪些GPU架构限制？",
    "reference": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "prediction": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SIMD硬件如何提升ConvNets卷积层的计算吞吐量？",
    "reference": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "prediction": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过填充优化（Padding）提升内存访问效率？",
    "reference": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "prediction": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽瓶颈为何对矩阵乘法算子影响显著？",
    "reference": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "prediction": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何使用自动变量（寄存器）提升计算速度？",
    "reference": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "prediction": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM多线程调度如何隐藏矩阵乘法算子的内存延迟？",
    "reference": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "prediction": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子如何将2D输入线性化以适配全局内存存储？",
    "reference": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i]，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "prediction": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存缓存对卷积核访问有何优化？",
    "reference": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "prediction": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的线程块大小选择需匹配哪些GPU架构参数？",
    "reference": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "prediction": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过边界检查处理非TILE_WIDTH倍数的矩阵？",
    "reference": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH=256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "prediction": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH为256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存带宽比全局内存高多少，对卷积算子有何意义？",
    "reference": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "prediction": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何复用前向传播的中间数据？",
    "reference": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "prediction": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp大小（32线程）如何影响卷积算子的线程块设计？",
    "reference": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "prediction": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrVal数组，如何确保线程访问的合并性？",
    "reference": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "prediction": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，__syncthreads()的作用是什么？",
    "reference": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "prediction": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多通道内存（如GDDR6）如何提升矩阵乘法算子的带宽？",
    "reference": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "prediction": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的掩码（Mask）存储在常量内存的优势是什么？",
    "reference": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "prediction": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM核心数如何影响ConvNets卷积层的计算速度？",
    "reference": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "prediction": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理行数远大于线程块数的稀疏矩阵？",
    "reference": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "prediction": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，TILE_WIDTH选择为16或32的依据是什么？",
    "reference": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "prediction": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存对齐要求如何影响卷积算子的输入数据存储？",
    "reference": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "prediction": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何处理多通道输入（如RGB图像）？",
    "reference": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "prediction": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存对矩阵乘法算子的tiling优化有何补充？",
    "reference": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "prediction": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrColInd数组，为何需要与csrVal数组一一对应？",
    "reference": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "prediction": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过循环展开提升指令执行效率？",
    "reference": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "prediction": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的功耗限制如何影响卷积算子的性能调优？",
    "reference": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "prediction": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Pvalue累加变量为何要声明为volatile？",
    "reference": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "prediction": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的异步执行如何提升SpMV算子的整体吞吐量？",
    "reference": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "prediction": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的输出数组P，如何分配全局内存以避免内存碎片？",
    "reference": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "prediction": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何在SpMV算子中避免？",
    "reference": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "prediction": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何计算卷积核的梯度？",
    "reference": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "prediction": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的计算能力（如Compute Capability 8.6）对矩阵乘法算子有何影响？",
    "reference": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "prediction": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理空行（无非零元素的矩阵行）？",
    "reference": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则线程跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "prediction": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则线程跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaMemcpyToSymbol的作用是什么？",
    "reference": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "prediction": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存控制器数量如何影响SpMV算子的带宽？",
    "reference": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "prediction": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的线程块维度（如dim3(16,16)）为何选择二维？",
    "reference": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "prediction": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp调度器如何选择就绪warp执行？",
    "reference": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已加载完成的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "prediction": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已加载完成的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子的halo细胞加载，如何避免线程冗余计算？",
    "reference": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "prediction": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存容量限制（64KB）如何影响ConvNets的大尺寸卷积核？",
    "reference": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "prediction": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的输出向量初始化为何要使用cudaMemset？",
    "reference": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "prediction": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过blockDim和gridDim计算总线程数？",
    "reference": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "prediction": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存一致性对多SM执行SpMV算子有何意义？",
    "reference": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "prediction": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中卷积算子的__shared__变量声明为何要指定大小？",
    "reference": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "prediction": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的张量核心（Tensor Cores）如何提升ConvNets卷积层性能？",
    "reference": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "prediction": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrRowPtr数组为何要比矩阵行数多1？",
    "reference": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "prediction": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何处理浮点数溢出？",
    "reference": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "prediction": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽与计算吞吐量的比例（如1TB/s带宽、10TFLOPS计算）如何影响卷积算子？",
    "reference": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "prediction": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何实现零填充（Zero Padding）？",
    "reference": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "prediction": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM调度器如何分配线程块到SM？",
    "reference": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "prediction": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过线程私有化提升性能？",
    "reference": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "prediction": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaGetDeviceProperties的作用是什么？",
    "reference": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "prediction": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多进程并发对SpMV算子有何影响？",
    "reference": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "prediction": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Nds[ty][tx] = N[(ph*TILE_WIDTH + ty)*Width + Col]索引计算的含义是什么？",
    "reference": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "prediction": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存写回策略对卷积算子有何影响？",
    "reference": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "prediction": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的__device__函数作用是什么？",
    "reference": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "prediction": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何通过im2col转换提升性能？",
    "reference": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "prediction": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA编程，tiled矩阵乘法算子如何通过数据复用提升计算/内存访问比？",
    "reference": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累加 ... }。",
    "prediction": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累",
    "rougeL_f1": 1.0
  },
  {
    "question": "算法层面如何优化SpMV算子的负载均衡，CUDA编程如何实现该优化？",
    "reference": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "prediction": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，2D卷积算子如何通过分块大小选择平衡共享内存占用与并行度？",
    "reference": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "prediction": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "rougeL_f1": 1.0
  },
  {
    "question": "ConvNets的卷积层算法如何转换为矩阵乘法，CUDA编程如何高效实现该转换？",
    "reference": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int channel = blockIdx.z;\n    if (row < height && col < width) {\n        int idx = channel * height * width + row * width + col;\n        // 展开卷积窗口到x_col\n        for (int k = 0; k < kernel_size; k++) {\n            for (int l = 0; l < kernel_size; l++) {\n                int x_row = row + k - kernel_size/2;\n                int x_col = col + l - kernel_size/2;\n                if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n                    x_col[col * kernel_sizekernel_size + kkernel_size + l] = x[channel * height * width + x_row * width + x_col];\n                }\n            }\n        }\n    }\n}\n之后调用GEMM内核完成矩阵乘法，利用矩阵乘法的优化特性提升卷积性能。",
    "prediction": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y",
    "rougeL_f1": 0.5029940119760479
  },
  {
    "question": "算法层面如何处理稀疏矩阵的转置以优化SpMV算子，CUDA编程如何实现转置？",
    "reference": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_csrVal, int n) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < n) {\n        for (int i = csrRowPtr[row]; i < csrRowPtr[row+1]; i++) {\n            int col = csrColInd[i];\n            float val = csrVal[i];\n            int pos = atomicAdd(&t_csrRowPtr[col+1], 1);\n            t_csrColInd[pos] = row;\n            t_csrVal[pos] = val;\n        }\n    }\n}\n转置后SpMV算子的内存访问更易合并，提升性能。",
    "prediction": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_c",
    "rougeL_f1": 0.5535714285714286
  },
  {
    "question": "结合算法与CUDA，矩阵乘法算子如何通过循环展开提升指令吞吐量？",
    "reference": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE_WIDTH较大的场景。",
    "prediction": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE",
    "rougeL_f1": 0.9841269841269841
  },
  {
    "question": "卷积算子的算法如何通过“ halo 细胞复用”减少数据传输，CUDA编程如何实现？",
    "reference": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "prediction": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "SpMV算子的算法如何通过“行合并”优化，CUDA编程如何实现该优化？",
    "reference": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "prediction": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的反向传播算子如何优化梯度计算的内存访问？",
    "reference": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] += dY_ds[ty][tx] * X_ds[ty][tx];\n通过共享内存优化内存局部性，减少全局内存访问，提升梯度计算速度。",
    "prediction": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] +=",
    "rougeL_f1": 0.9090909090909091
  },
  {
    "question": "矩阵乘法算子的算法如何处理非正方形矩阵，CUDA编程如何调整线程映射？",
    "reference": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0; k < K; k += TILE_K) {\n        // 加载矩形子矩阵\n        Mds[ty][tk] = M[Row*K + k + tk];\n        Nds[tk][tx] = N[(k + tk)N + Col];\n        __syncthreads();\n        // 乘法累加\n        for (int tk = 0; tk < TILE_K; tk++) {\n            Pvalue += Mds[ty][tk] * Nds[tk][tx];\n        }\n    }\n    P[RowN + Col] = Pvalue;\n}\n适配非正方形矩阵的维度，确保计算正确性和性能。",
    "prediction": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0;",
    "rougeL_f1": 0.7248322147651006
  },
  {
    "question": "卷积算子的算法如何通过“多尺度分块”优化，CUDA编程如何实现？",
    "reference": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, width, height, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH - 1]），适配不同输入尺度。",
    "prediction": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, width, height, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH -",
    "rougeL_f1": 0.98989898989899
  },
  {
    "question": "SpMV算子的算法如何通过“原子操作优化”处理输出向量的累加，CUDA编程如何实现？",
    "reference": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "prediction": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的卷积层算子如何优化多通道输入的计算？",
    "reference": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size + l];\n    }\n}\nY[row * width + col] += Pvalue;\n通过三维线程块（gridDim.z=channels）并行处理多通道，提升计算效率。",
    "prediction": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size",
    "rougeL_f1": 0.9291338582677166
  },
  {
    "question": "矩阵乘法算子的算法如何通过“预取”优化内存访问，CUDA编程如何实现？",
    "reference": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next_ph*TILE_WIDTH + ty)*Width + Col];\n    }\n    __syncthreads();\n    // 计算当前子矩阵\n    for (int k = 0; k < TILE_WIDTH; ++k) {\n        Pvalue += Mds0[ty][k] * Nds0[k][tx];\n    }\n    // 切换缓冲\n    swap(Mds0, Mds1);\n    swap(Nds0, Nds1);\n}\n通过计算与预取重叠，减少内存延迟对性能的影响。",
    "prediction": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next",
    "rougeL_f1": 0.7358490566037735
  },
  {
    "question": "卷积算子的算法如何处理“空洞卷积”（Dilated Convolution），CUDA编程如何调整索引计算？",
    "reference": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n            Pvalue += X[x_rowpitch + x_col] * W[kkernel_size + l];\n        }\n    }\n}\n通过k*dilation和l*dilation跳过空洞位置，实现空洞卷积的计算逻辑。",
    "prediction": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width",
    "rougeL_f1": 0.890625
  },
  {
    "question": "SpMV算子的算法如何通过“压缩存储格式转换”（如CSR转ELL）优化，CUDA编程如何实现转换？",
    "reference": "算法上，ELL格式将稀疏矩阵按列存储，每行非零元素填充到固定长度，适合并行访问；CUDA编程中，实现CSR到ELL的转换：1. 统计最大非零元素行数（max_nnz）；2. 初始化ELL格式的col_ind和val数组（维度为n×max_nnz）；3. 线程块处理每行，将非零元素填入ELL数组，核心代码：\nglobal void csr_to_ell_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* ell_col_ind, float* ell_val, int n, int max_nnz) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < n) {\n        for (int i = 0; i < max_nnz; i++) {\n            int idx = csrRowPtr[row] + i;\n            if (idx < csrRowPtr[row+1]) {\n                ell_col_ind[row * max_nnz + i] = csrColInd[idx];\n                ell_val[row * max_nnz + i] = csrVal[idx];\n            } else {\n                ell_col_ind[row * max_nnz + i] = -1; // 标记无效\n                ell_val[row * max_nnz + i] = 0;\n            }\n        }\n    }\n}\nELL格式的SpMV算子可通过线程并行处理每行，提升访问效率。",
    "prediction": "算法上，ELL格式将稀疏矩阵按列存储，每行非零元素填充到固定长度，适合并行访问；CUDA编程中，实现CSR到ELL的转换：1. 统计最大非零元素行数（max_nnz）；2. 初始化ELL格式的col_ind和val数组（维度为n×max_nnz）；3. 线程块处理每行，将非零元素填入ELL数组，核心代码：\nglobal void csr_to_ell_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* ell_col_ind, float* ell_val, int n, int max_nnz) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (",
    "rougeL_f1": 0.6451612903225806
  },
  {
    "question": "结合算法与CUDA，矩阵乘法算子如何通过“精度调整”平衡性能与准确性？",
    "reference": "算法上，根据应用需求选择精度（如FP32用于普通计算，FP16用于ConvNets推理，FP64用于高精度计算）；CUDA编程中，使用对应精度的变量和指令，如FP16的half类型，配合Tensor Cores，核心代码：\nglobal void gemm_fp16_kernel(half* M, half* N, half* P, int M_rows, int K, int N_cols) {\n    // 使用half精度变量\n    half Pvalue = __float2half(0.0f);\n    int Row = blockIdx.y * blockDim.y + threadIdx.y;\n    int Col = blockIdx.x * blockDim.x + threadIdx.x;\n    if (Row < M_rows && Col < N_cols) {\n        for (int k = 0; k < K; k++) {\n            Pvalue = __hadd(Pvalue, __hmul(M[RowK + k], N[kN_cols + Col]));\n        }\n        P[Row*N_cols + Col] = Pvalue;\n    }\n}\nFP16精度可提升内存带宽和计算吞吐量，同时满足多数应用的准确性要求。\n三、难题（16道，含Triton、TileLang、PTX编程）",
    "prediction": "算法上，根据应用需求选择精度（如FP32用于普通计算，FP16用于ConvNets推理，FP64用于高精度计算）；CUDA编程中，使用对应精度的变量和指令，如FP16的half类型，配合Tensor Cores，核心代码：\nglobal void gemm_fp16_kernel(half* M, half* N, half* P, int M_rows, int K, int N_cols) {\n    // 使用half精度变量\n    half Pvalue = __float2half(0.0f);\n    int Row = blockIdx.y * blockDim.y + threadIdx.y;\n    int Col = blockIdx.x * blockDim.x + threadIdx.x;\n    if (Row < M_rows && Col < N_cols) {\n        for",
    "rougeL_f1": 0.8082191780821918
  },
  {
    "question": "如何用Triton实现ConvNets的3×3卷积层，并通过自动分块优化提升性能？",
    "reference": "Triton通过Python-like语法定义内核，自动处理分块、内存布局优化，无需手动管理共享内存。实现步骤：1. 定义输入（x）、权重（w）、输出（y）的张量布局，指定块大小（block_size）；2. 使用triton.jit装饰器标记内核，启用自动分块；3. 在内核中通过指针算术实现滑动窗口卷积，Triton编译器自动将输入和权重分块到共享内存，优化内存局部性。核心代码：\nimport triton\nimport triton.language as tl\n@triton.jit\ndef conv3x3_kernel(\n    x_ptr, w_ptr, y_ptr,\n    x_stride, y_stride,\n    kernel_size: tl.constexpr,\n    block_size: tl.constexpr\n):\n    # 线程映射到输出元素\n    row = tl.program_id(0) * block_size + tl.thread_id(0)\n    col = tl.program_id(1) * block_size + tl.thread_id(1)\n    # 初始化累加器\n    y_val = tl.float32(0.0)\n    # 滑动窗口卷积\n    for k in tl.range(0, kernel_size):\n        for l in tl.range(0, kernel_size):\n            # 计算输入索引，处理边界\n            x_row = row + k - kernel_size//2\n            x_col = col + l - kernel_size//2\n            x_val = tl.load(x_ptr + x_row * x_stride + x_col, mask=(x_row >=0) & (x_row < tl.shape(x_ptr)[0]) & (x_col >=0) & (x_col < tl.shape(x_ptr)[1]), other=0.0)\n            w_val = tl.load(w_ptr + k * kernel_size + l)\n            y_val += x_val * w_val\n    # 存储输出\n    tl.store(y_ptr + row * y_stride + col, y_val, mask=(row < tl.shape(y_ptr)[0]) & (col < tl.shape(y_ptr)[1]))\n调用内核\nblock_size = 16\ngrid = (triton.cdiv(height, block_size), triton.cdiv(width, block_size))\nconv3x3_kernel[grid](x, w, y, x.stride(0), y.stride(0), kernel_size=3, block_size=block_size)\nTriton的自动分块优化可匹配甚至超越手工CUDA实现，尤其适合快速迭代卷积层架构。",
    "prediction": "Triton通过Python-like语法定义内核，自动处理分块、内存布局优化，无需手动管理共享内存。实现步骤：1. 定义输入（x）、权重（w）、输出（y）的张量布局，指定块大小（block_size）；2. 使用triton.jit装饰器标记内核，启用自动分块；3. 在内核中通过指针算术实现滑动窗口卷积，Triton编译器自动将输入和权重分块到共享内存，优化内存局部性。核心代码：\nimport triton\nimport triton.language as tl\n@triton.jit\ndef conv3x3_kernel(\n    x_ptr, w_ptr, y_ptr,\n    x_stride, y_stride",
    "rougeL_f1": 0.2903225806451613
  },
  {
    "question": "如何用TileLang优化SpMV算子的CSR格式访问，提升非合并内存访问效率？",
    "reference": "TileLang是领域特定语言，专注于张量和稀疏计算优化，通过声明式语法指定分块和访问模式。实现步骤：1. 定义CSR格式的稀疏矩阵类型和向量类型；2. 声明分块策略（如按行分块，块大小为64）；3. 指定访问模式为“行内连续访问”，TileLang编译器自动优化内存布局和线程映射，减少非合并访问。核心代码：\n// TileLang代码\ntype CSRMatrix<T> = {\n    row_ptr: [Int32],\n    col_ind: [Int32],\n    val: [T],\n    shape: (Int32, Int32)\n}\ntype Vector<T> = [T]\n@tile\ndef spmv(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    let (n_rows, n_cols) = A.shape;\n    let y: Vector<Float32> = zeros(n_rows);\n    // 按行分块，块大小64\n    @tile(size=64)\n    for row in 0..n_rows-1 {\n        let start = A.row_ptr[row];\n        let end = A.row_ptr[row+1];\n        // 行内连续访问非零元素\n        @access(pattern=\"contiguous\")\n        for idx in start..end-1 {\n            let col = A.col_ind[idx];\n            let val = A.val[idx];\n            y[row] += val * x[col];\n        }\n    }\n    return y;\n}\nTileLang编译器会分析访问模式，将行内非零元素按连续内存地址重排，或通过硬件预取优化，提升非合并访问的有效带宽，进而提升SpMV算子性能。",
    "prediction": "TileLang是领域特定语言，专注于张量和稀疏计算优化，通过声明式语法指定分块和访问模式。实现步骤：1. 定义CSR格式的稀疏矩阵类型和向量类型；2. 声明分块策略（如按行分块，块大小为64）；3. 指定访问模式为“行内连续访问”，TileLang编译器自动优化内存布局和线程映射，减少非合并访问。核心代码：\n// TileLang代码\ntype CSRMatrix<T> = {\n    row_ptr: [Int32],\n    col_ind: [Int32],\n    val: [T],\n    shape: (Int32, Int32)\n}\ntype Vector<T",
    "rougeL_f1": 0.3875968992248062
  },
  {
    "question": "Triton实现的矩阵乘法算子如何与CUDA的tiled实现对比，优势在哪里？",
    "reference": "Triton实现无需手动管理共享内存、线程块配置和合并访问，编译器自动优化；CUDA tiled实现需手动设计分块大小、共享内存数组和索引计算。Triton优势：1. 自动分块适配不同GPU架构（如A100、RTX 3090），无需修改代码；2. 自动处理内存合并访问和bank冲突；3. 支持动态块大小调整，适配不同矩阵尺寸；4. 代码简洁，开发效率高。示例Triton矩阵乘法代码：\n@triton.jit\ndef gemm_kernel(A, B, C, M, K, N, stride_am, stride_ak, stride_bk, stride_bn, stride_cm, stride_cn, BLOCK_SIZE: tl.constexpr):\n    # 自动分块和线程映射\n    pid = tl.program_id(0)\n    block_idx_m = pid // (N // BLOCK_SIZE)\n    block_idx_n = pid % (N // BLOCK_SIZE)\n    # 加载块到寄存器\n    a_block = tl.load(A + block_idx_m * BLOCK_SIZE * stride_am + tl.arange(0, BLOCK_SIZE)[:, None] * stride_am + tl.arange(0, BLOCK_SIZE)[None, :] * stride_ak)\n    b_block = tl.load(B + tl.arange(0, BLOCK_SIZE)[:, None] * stride_bk + block_idx_n * BLOCK_SIZE * stride_bn + tl.arange(0, BLOCK_SIZE)[None, :] * stride_bn)\n    # 矩阵乘法\n    c_block = tl.dot(a_block, b_block)\n    # 存储结果\n    tl.store(C + block_idx_m * BLOCK_SIZE * stride_cm + tl.arange(0, BLOCK_SIZE)[:, None] * stride_cm + block_idx_n * BLOCK_SIZE * stride_cn + tl.arange(0, BLOCK_SIZE)[None, :] * stride_cn, c_block)\n相比CUDA手动实现，Triton代码行数减少80%以上，性能损失通常在10%以内，开发效率大幅提升。",
    "prediction": "Triton实现无需手动管理共享内存、线程块配置和合并访问，编译器自动优化；CUDA tiled实现需手动设计分块大小、共享内存数组和索引计算。Triton优势：1. 自动分块适配不同GPU架构（如A100、RTX 3090），无需修改代码；2. 自动处理内存合并访问和bank冲突；3. 支持动态块大小调整，适配不同矩阵尺寸；4. 代码简洁，开发效率高。示例Triton矩阵乘法代码：\n@triton.jit\ndef gemm_kernel(A, B, C, M, K, N, stride_am, stride_ak, stride_bk, stride_bn,",
    "rougeL_f1": 0.336734693877551
  },
  {
    "question": "如何用TileLang实现2D卷积的tiled优化，自动处理halo细胞加载？",
    "reference": "TileLang通过@halo注解声明halo细胞大小，编译器自动生成halo加载代码，无需手动计算halo索引。实现步骤：1. 定义输入、权重、输出张量；2. 用@tile指定输出分块大小，@halo指定halo细胞尺寸（如上下左右各1个）；3. 编写卷积计算逻辑，TileLang自动加载核心细胞和halo细胞。核心代码：\n// TileLang代码\ntype Tensor2D<T> = {\n    data: [T],\n    width: Int32,\n    height: Int32,\n    pitch: Int32\n}\n@tile\ndef conv2d_tiled(x: Tensor2D<Float32>, w: Tensor2D<Float32>, mask_size: Int32) -> Tensor2D<Float32> {\n    let halo = (mask_size - 1) // 2;\n    let tile_size = 16;\n    // 输出分块，每个块带halo细胞\n    @tile(size=tile_size, halo=(halo, halo))\n    for row in 0..x.height-1 {\n        @tile(size=tile_size, halo=(halo, halo))\n        for col in 0..x.width-1 {\n            let y_val: Float32 = 0.0;\n            for k in 0..mask_size-1 {\n                for l in 0..mask_size-1 {\n                    // 自动访问halo细胞，无需手动判断边界\n                    let x_val = x.data[(row + k - halo) * x.pitch + (col + l - halo)];\n                    let w_val = w.data[k * mask_size + l];\n                    y_val += x_val * w_val;\n                }\n            }\n            // 存储输出块核心细胞\n            output.data[row * output.pitch + col] = y_val;\n        }\n    }\n    return output;\n}\nTileLang编译器自动生成halo细胞的加载代码，处理边界条件，同时优化分块内的内存访问，大幅简化tiled卷积的实现复杂度。",
    "prediction": "TileLang通过@halo注解声明halo细胞大小，编译器自动生成halo加载代码，无需手动计算halo索引。实现步骤：1. 定义输入、权重、输出张量；2. 用@tile指定输出分块大小，@halo指定halo细胞尺寸（如上下左右各1个）；3. 编写卷积计算逻辑，TileLang自动加载核心细胞和halo细胞。核心代码：\n// TileLang代码\ntype Tensor2D<T> = {\n    data: [T],\n    width: Int32,\n    height: Int32,\n    pitch: Int32\n}\n@tile\ndef conv2d_tiled(x: Tensor2D<Float32>,",
    "rougeL_f1": 0.37714285714285717
  },
  {
    "question": "Triton实现的ConvNets反向传播算子，如何利用自动微分和内存复用提升性能？",
    "reference": "Triton结合PyTorch的自动微分框架，可自动生成梯度计算内核，同时通过内存复用减少中间数据存储。实现步骤：1. 用Triton定义前向卷积内核；2. 借助PyTorch的torch.autograd.Function封装前向和反向传播；3. 反向传播中复用前向的输入和权重分块缓存，避免重复加载。核心代码片段：\nclass TritonConv2d(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x, w):\n        # 前向传播，调用Triton卷积内核\n        y = triton_conv2d_forward(x, w)\n        # 保存中间数据用于反向传播\n        ctx.save_for_backward(x, w)\n        return y\n    @staticmethod\n    def backward(ctx, grad_y):\n        x, w = ctx.saved_tensors\n        # 反向传播，调用Triton梯度内核，复用前向分块缓存\n        grad_x = triton_conv2d_backward_input(x, w, grad_y)\n        grad_w = triton_conv2d_backward_weight(x, w, grad_y)\n        return grad_x, grad_w\n自动微分调用\nx = torch.randn(1, 3, 256, 256).cuda()\nw = torch.randn(64, 3, 3, 3).cuda()\nconv = TritonConv2d.apply\ny = conv(x, w)\ny.sum().backward()\nTriton的自动微分支持减少手动编写梯度内核的工作量，内存复用优化减少中间数据的全局内存存储和访问，提升反向传播性能。",
    "prediction": "Triton结合PyTorch的自动微分框架，可自动生成梯度计算内核，同时通过内存复用减少中间数据存储。实现步骤：1. 用Triton定义前向卷积内核；2. 借助PyTorch的torch.autograd.Function封装前向和反向传播；3. 反向传播中复用前向的输入和权重分块缓存，避免重复加载。核心代码片段：\nclass TritonConv2d(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x, w):\n        # 前向传播，调用Triton卷积内核\n        y = triton_conv2d_forward(x, w)\n        # 保存中间",
    "rougeL_f1": 0.43750000000000006
  },
  {
    "question": "如何用TileLang优化稀疏矩阵转置后的SpMV算子，利用转置后的连续访问模式？",
    "reference": "TileLang通过@transpose注解自动优化转置矩阵的访问模式，结合分块策略提升并行度。实现步骤：1. 定义转置后的稀疏矩阵（如CSC格式）；2. 用@tile指定按列分块，匹配转置后的连续访问；3. 编写SpMV计算逻辑，TileLang自动优化线程映射和内存访问。核心代码：\n// TileLang代码\n@tile\ndef spmv_transposed(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    // 转置矩阵为CSC格式，按列分块\n    let A_t = @transpose(A, format=\"CSC\");\n    let (n_rows, n_cols) = A_t.shape;\n    let y: Vector<Float32> = zeros(n_rows);\n    // 按列分块，块大小64\n    @tile(size=64, dim=1)\n    for col in 0..n_cols-1 {\n        let start = A_t.col_ptr[col];\n        let end = A_t.col_ptr[col+1];\n        // 列内连续访问非零元素\n        @access(pattern=\"contiguous\")\n        for idx in start..end-1 {\n            let row = A_t.row_ind[idx];\n            let val = A_t.val[idx];\n            y[row] += val * x[col];\n        }\n    }\n    return y;\n}\n转置后的CSC格式让列内非零元素连续存储，TileLang的按列分块和连续访问优化，使线程访问触发合并访问，大幅提升内存效率，相比原CSR格式的SpMV算子性能提升30%-50%。",
    "prediction": "TileLang通过@transpose注解自动优化转置矩阵的访问模式，结合分块策略提升并行度。实现步骤：1. 定义转置后的稀疏矩阵（如CSC格式）；2. 用@tile指定按列分块，匹配转置后的连续访问；3. 编写SpMV计算逻辑，TileLang自动优化线程映射和内存访问。核心代码：\n// TileLang代码\n@tile\ndef spmv_transposed(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    // 转置矩阵为CSC格式，按列分块\n    let A_t = @transpose(A, format=\"CSC\");\n    let (n",
    "rougeL_f1": 0.45714285714285713
  },
  {
    "question": "Triton与CUDA的SpMV算子在处理大规模稀疏矩阵时，性能差异的主要原因是什么？",
    "reference": "主要原因在于内存访问优化和调度开销：1. Triton的自动分块和预取优化更适配大规模矩阵的非零元素分布，可动态调整分块大小，减少内存事务；2. Triton的线程调度由编译器优化，减少CUDA手动实现中的调度冗余（如线程块空闲）；3. Triton支持更灵活的精度调整（如TF32），在大规模计算中提升吞吐量；4. 大规模矩阵下，Triton的自动内存复用减少中间数据存储，降低全局内存带宽压力。例如处理1000万行、非零元素密度1%的稀疏矩阵，Triton实现的性能通常比未优化的CUDA实现高20%-40%，接近手工优化的CUDA实现，但开发效率提升数倍。",
    "prediction": "主要原因在于内存访问优化和调度开销：1. Triton的自动分块和预取优化更适配大规模矩阵的非零元素分布，可动态调整分块大小，减少内存事务；2. Triton的线程调度由编译器优化，减少CUDA手动实现中的调度冗余（如线程块空闲）；3. Triton支持更灵活的精度调整（如TF32），在大规模计算中提升吞吐量；4. 大规模矩阵下，Triton的自动内存复用减少中间数据存储，降低全局内存带宽压力。例如处理1000万行、非零元素密度1%的稀疏矩阵，Triton实现的性能通常比未优化的CUDA",
    "rougeL_f1": 0.9032258064516129
  },
  {
    "question": "如何用TileLang实现ConvNets的深度卷积（Depthwise Convolution），优化组内内存局部性？",
    "reference": "深度卷积将输入通道与输出通道一一对应，组内卷积独立计算，TileLang通过@group注解指定通道分组，优化组内数据复用。实现步骤：1. 定义输入（多通道）、深度卷积核（单通道输入、单通道输出）；2. 用@group按通道分组（每组1个输入通道、1个输出通道）；3. 编写组内卷积逻辑，TileLang自动优化组内数据的共享内存存储。核心代码：\n// TileLang代码\n@tile\ndef depthwise_conv(x: Tensor4D<Float32>, w: Tensor4D<Float32>, kernel_size: Int32) -> Tensor4D<Float32> {\n    let (batch, in_channels, height, width) = x.shape;\n    let (out_channels, _, _, _) = w.shape;\n    assert(in_channels == out_channels); // 深度卷积通道数一致\n    let y: Tensor4D<Float32> = zeros((batch, out_channels, height, width));\n    // 按通道分组，每组1个输入+1个输出通道\n    @group(dim=1, size=1)\n    for c in 0..in_channels-1 {\n        @tile(size=16, dim=2)\n        for row in 0..height-1 {\n            @tile(size=16, dim=3)\n            for col in 0..width-1 {\n                let y_val: Float32 = 0.0;\n                for k in 0..kernel_size-1 {\n                    for l in 0..kernel_size-1 {\n                        let x_row = row + k - kernel_size//2;\n                        let x_col = col + l - kernel_size//2;\n                        let x_val = x.data[batch][c][x_row][x_col] if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) else 0.0;\n                        let w_val = w.data[c][0][k][l];\n                        y_val += x_val * w_val;\n                    }\n                }\n                y.data[batch][c][row][col] = y_val;\n            }\n        }\n    }\n    return y;\n}\nTileLang的通道分组优化让组内数据集中存储，减少共享内存访问冲突，提升组内数据复用率，深度卷积性能比普通卷积提升2-3倍，适合移动设备和边缘计算场景。",
    "prediction": "深度卷积将输入通道与输出通道一一对应，组内卷积独立计算，TileLang通过@group注解指定通道分组，优化组内数据复用。实现步骤：1. 定义输入（多通道）、深度卷积核（单通道输入、单通道输出）；2. 用@group按通道分组（每组1个输入通道、1个输出通道）；3. 编写组内卷积逻辑（@tile指定输入和输出tile大小）。核心代码：\n// TileLang代码\n@tile\ndef depthwise_conv(x: Tensor4D<Float32>, w: Tensor4D<Float32>, kernel_size: Int32) -> Tensor4D<Float32> {\n    let",
    "rougeL_f1": 0.24154589371980675
  },
  {
    "question": "CUDA中矩阵乘法算子如何利用共享内存减少全局内存访问？",
    "reference": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "prediction": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构中SM的资源分配如何限制矩阵乘法算子的并行度？",
    "reference": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "prediction": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过线程索引映射实现1D输入的元素访问？",
    "reference": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "prediction": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp divergence为何会影响卷积算子的边界处理性能？",
    "reference": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "prediction": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子基于CSR格式时，线程如何映射到矩阵非零元素？",
    "reference": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "prediction": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的全局内存合并访问对SpMV算子性能有何影响？",
    "reference": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，提升内存访问效率，进而提升SpMV算子吞吐量。",
    "prediction": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，减少内存事务数量，提升带宽利用率，进而提升SpMV算子吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积神经网络卷积层算子中，如何使用常量内存存储卷积核？",
    "reference": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "prediction": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何影响tiled矩阵乘法性能？",
    "reference": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "prediction": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子如何处理边界的“幽灵细胞”？",
    "reference": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "prediction": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存对稀疏矩阵向量乘法（SpMV）有何优化作用？",
    "reference": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "prediction": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过线程块维度设置提升并行效率？",
    "reference": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "prediction": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，线程块的TILE_SIZE选择需考虑哪些GPU架构限制？",
    "reference": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "prediction": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SIMD硬件如何提升ConvNets卷积层的计算吞吐量？",
    "reference": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "prediction": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过填充优化（Padding）提升内存访问效率？",
    "reference": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "prediction": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽瓶颈为何对矩阵乘法算子影响显著？",
    "reference": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "prediction": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何使用自动变量（寄存器）提升计算速度？",
    "reference": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "prediction": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM多线程调度如何隐藏矩阵乘法算子的内存延迟？",
    "reference": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "prediction": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子如何将2D输入线性化以适配全局内存存储？",
    "reference": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i]，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "prediction": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存缓存对卷积核访问有何优化？",
    "reference": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "prediction": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的线程块大小选择需匹配哪些GPU架构参数？",
    "reference": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "prediction": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过边界检查处理非TILE_WIDTH倍数的矩阵？",
    "reference": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH=256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "prediction": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH为256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存带宽比全局内存高多少，对卷积算子有何意义？",
    "reference": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "prediction": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何复用前向传播的中间数据？",
    "reference": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "prediction": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp大小（32线程）如何影响卷积算子的线程块设计？",
    "reference": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "prediction": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrVal数组，如何确保线程访问的合并性？",
    "reference": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "prediction": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，__syncthreads()的作用是什么？",
    "reference": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "prediction": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多通道内存（如GDDR6）如何提升矩阵乘法算子的带宽？",
    "reference": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "prediction": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的掩码（Mask）存储在常量内存的优势是什么？",
    "reference": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "prediction": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM核心数如何影响ConvNets卷积层的计算速度？",
    "reference": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "prediction": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理行数远大于线程块数的稀疏矩阵？",
    "reference": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "prediction": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，TILE_WIDTH选择为16或32的依据是什么？",
    "reference": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "prediction": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存对齐要求如何影响卷积算子的输入数据存储？",
    "reference": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "prediction": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何处理多通道输入（如RGB图像）？",
    "reference": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "prediction": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存对矩阵乘法算子的tiling优化有何补充？",
    "reference": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "prediction": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrColInd数组，为何需要与csrVal数组一一对应？",
    "reference": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "prediction": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过循环展开提升指令执行效率？",
    "reference": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "prediction": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的功耗限制如何影响卷积算子的性能调优？",
    "reference": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "prediction": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Pvalue累加变量为何要声明为volatile？",
    "reference": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "prediction": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的异步执行如何提升SpMV算子的整体吞吐量？",
    "reference": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "prediction": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的输出数组P，如何分配全局内存以避免内存碎片？",
    "reference": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "prediction": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何在SpMV算子中避免？",
    "reference": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "prediction": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何计算卷积核的梯度？",
    "reference": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "prediction": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的计算能力（如Compute Capability 8.6）对矩阵乘法算子有何影响？",
    "reference": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "prediction": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理空行（无非零元素的矩阵行）？",
    "reference": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则线程跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "prediction": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaMemcpyToSymbol的作用是什么？",
    "reference": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "prediction": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存控制器数量如何影响SpMV算子的带宽？",
    "reference": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "prediction": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的线程块维度（如dim3(16,16)）为何选择二维？",
    "reference": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "prediction": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp调度器如何选择就绪warp执行？",
    "reference": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已加载完成的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "prediction": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已获取数据的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子的halo细胞加载，如何避免线程冗余计算？",
    "reference": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "prediction": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存容量限制（64KB）如何影响ConvNets的大尺寸卷积核？",
    "reference": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "prediction": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的输出向量初始化为何要使用cudaMemset？",
    "reference": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "prediction": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过blockDim和gridDim计算总线程数？",
    "reference": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "prediction": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存一致性对多SM执行SpMV算子有何意义？",
    "reference": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "prediction": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中卷积算子的__shared__变量声明为何要指定大小？",
    "reference": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "prediction": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的张量核心（Tensor Cores）如何提升ConvNets卷积层性能？",
    "reference": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "prediction": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrRowPtr数组为何要比矩阵行数多1？",
    "reference": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "prediction": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何处理浮点数溢出？",
    "reference": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "prediction": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽与计算吞吐量的比例（如1TB/s带宽、10TFLOPS计算）如何影响卷积算子？",
    "reference": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "prediction": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何实现零填充（Zero Padding）？",
    "reference": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "prediction": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM调度器如何分配线程块到SM？",
    "reference": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "prediction": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过线程私有化提升性能？",
    "reference": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "prediction": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaGetDeviceProperties的作用是什么？",
    "reference": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "prediction": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多进程并发对SpMV算子有何影响？",
    "reference": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "prediction": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Nds[ty][tx] = N[(ph*TILE_WIDTH + ty)*Width + Col]索引计算的含义是什么？",
    "reference": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "prediction": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存写回策略对卷积算子有何影响？",
    "reference": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "prediction": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的__device__函数作用是什么？",
    "reference": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "prediction": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何通过im2col转换提升性能？",
    "reference": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "prediction": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA编程，tiled矩阵乘法算子如何通过数据复用提升计算/内存访问比？",
    "reference": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累加 ... }。",
    "prediction": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累",
    "rougeL_f1": 1.0
  },
  {
    "question": "算法层面如何优化SpMV算子的负载均衡，CUDA编程如何实现该优化？",
    "reference": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "prediction": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，2D卷积算子如何通过分块大小选择平衡共享内存占用与并行度？",
    "reference": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "prediction": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "rougeL_f1": 1.0
  },
  {
    "question": "ConvNets的卷积层算法如何转换为矩阵乘法，CUDA编程如何高效实现该转换？",
    "reference": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int channel = blockIdx.z;\n    if (row < height && col < width) {\n        int idx = channel * height * width + row * width + col;\n        // 展开卷积窗口到x_col\n        for (int k = 0; k < kernel_size; k++) {\n            for (int l = 0; l < kernel_size; l++) {\n                int x_row = row + k - kernel_size/2;\n                int x_col = col + l - kernel_size/2;\n                if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n                    x_col[col * kernel_sizekernel_size + kkernel_size + l] = x[channel * height * width + x_row * width + x_col];\n                }\n            }\n        }\n    }\n}\n之后调用GEMM内核完成矩阵乘法，利用矩阵乘法的优化特性提升卷积性能。",
    "prediction": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y",
    "rougeL_f1": 0.5029940119760479
  },
  {
    "question": "算法层面如何处理稀疏矩阵的转置以优化SpMV算子，CUDA编程如何实现转置？",
    "reference": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_csrVal, int n) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < n) {\n        for (int i = csrRowPtr[row]; i < csrRowPtr[row+1]; i++) {\n            int col = csrColInd[i];\n            float val = csrVal[i];\n            int pos = atomicAdd(&t_csrRowPtr[col+1], 1);\n            t_csrColInd[pos] = row;\n            t_csrVal[pos] = val;\n        }\n    }\n}\n转置后SpMV算子的内存访问更易合并，提升性能。",
    "prediction": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_c",
    "rougeL_f1": 0.5535714285714286
  },
  {
    "question": "结合算法与CUDA，矩阵乘法算子如何通过循环展开提升指令吞吐量？",
    "reference": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE_WIDTH较大的场景。",
    "prediction": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE",
    "rougeL_f1": 0.9841269841269841
  },
  {
    "question": "卷积算子的算法如何通过“ halo 细胞复用”减少数据传输，CUDA编程如何实现？",
    "reference": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "prediction": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "SpMV算子的算法如何通过“行合并”优化，CUDA编程如何实现该优化？",
    "reference": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "prediction": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的反向传播算子如何优化梯度计算的内存访问？",
    "reference": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] += dY_ds[ty][tx] * X_ds[ty][tx];\n通过共享内存优化内存局部性，减少全局内存访问，提升梯度计算速度。",
    "prediction": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] +=",
    "rougeL_f1": 0.9090909090909091
  },
  {
    "question": "矩阵乘法算子的算法如何处理非正方形矩阵，CUDA编程如何调整线程映射？",
    "reference": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0; k < K; k += TILE_K) {\n        // 加载矩形子矩阵\n        Mds[ty][tk] = M[Row*K + k + tk];\n        Nds[tk][tx] = N[(k + tk)N + Col];\n        __syncthreads();\n        // 乘法累加\n        for (int tk = 0; tk < TILE_K; tk++) {\n            Pvalue += Mds[ty][tk] * Nds[tk][tx];\n        }\n    }\n    P[RowN + Col] = Pvalue;\n}\n适配非正方形矩阵的维度，确保计算正确性和性能。",
    "prediction": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0;",
    "rougeL_f1": 0.7248322147651006
  },
  {
    "question": "卷积算子的算法如何通过“多尺度分块”优化，CUDA编程如何实现？",
    "reference": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, width, height, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH - 1]），适配不同输入尺度。",
    "prediction": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, X_width, Y_width, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH",
    "rougeL_f1": 0.9504950495049505
  },
  {
    "question": "SpMV算子的算法如何通过“原子操作优化”处理输出向量的累加，CUDA编程如何实现？",
    "reference": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "prediction": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的卷积层算子如何优化多通道输入的计算？",
    "reference": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size + l];\n    }\n}\nY[row * width + col] += Pvalue;\n通过三维线程块（gridDim.z=channels）并行处理多通道，提升计算效率。",
    "prediction": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size",
    "rougeL_f1": 0.9291338582677166
  },
  {
    "question": "矩阵乘法算子的算法如何通过“预取”优化内存访问，CUDA编程如何实现？",
    "reference": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next_ph*TILE_WIDTH + ty)*Width + Col];\n    }\n    __syncthreads();\n    // 计算当前子矩阵\n    for (int k = 0; k < TILE_WIDTH; ++k) {\n        Pvalue += Mds0[ty][k] * Nds0[k][tx];\n    }\n    // 切换缓冲\n    swap(Mds0, Mds1);\n    swap(Nds0, Nds1);\n}\n通过计算与预取重叠，减少内存延迟对性能的影响。",
    "prediction": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next",
    "rougeL_f1": 0.7358490566037735
  },
  {
    "question": "卷积算子的算法如何处理“空洞卷积”（Dilated Convolution），CUDA编程如何调整索引计算？",
    "reference": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n            Pvalue += X[x_rowpitch + x_col] * W[kkernel_size + l];\n        }\n    }\n}\n通过k*dilation和l*dilation跳过空洞位置，实现空洞卷积的计算逻辑。",
    "prediction": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width",
    "rougeL_f1": 0.890625
  },
  {
    "question": "SpMV算子的算法如何通过“压缩存储格式转换”（如CSR转ELL）优化，CUDA编程如何实现转换？",
    "reference": "算法上，ELL格式将稀疏矩阵按列存储，每行非零元素填充到固定长度，适合并行访问；CUDA编程中，实现CSR到ELL的转换：1. 统计最大非零元素行数（max_nnz）；2. 初始化ELL格式的col_ind和val数组（维度为n×max_nnz）；3. 线程块处理每行，将非零元素填入ELL数组，核心代码：\nglobal void csr_to_ell_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* ell_col_ind, float* ell_val, int n, int max_nnz) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < n) {\n        for (int i = 0; i < max_nnz; i++) {\n            int idx = csrRowPtr[row] + i;\n            if (idx < csrRowPtr[row+1]) {\n                ell_col_ind[row * max_nnz + i] = csrColInd[idx];\n                ell_val[row * max_nnz + i] = csrVal[idx];\n            } else {\n                ell_col_ind[row * max_nnz + i] = -1; // 标记无效\n                ell_val[row * max_nnz + i] = 0;\n            }\n        }\n    }\n}\nELL格式的SpMV算子可通过线程并行处理每行，提升访问效率。",
    "prediction": "算法上，ELL格式将稀疏矩阵按列存储，每行非零元素填充到固定长度，适合并行访问；CUDA编程中，实现CSR到ELL的转换：1. 统计最大非零元素行数（max_nnz）；2. 初始化ELL格式的col_ind和val数组（维度为n×max_nnz）；3. 线程块处理每行，将非零元素填入ELL数组，核心代码：\nglobal void csr_to_ell_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* ell_col_ind, float* ell_val, int n, int max_nnz) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (",
    "rougeL_f1": 0.6451612903225806
  },
  {
    "question": "结合算法与CUDA，矩阵乘法算子如何通过“精度调整”平衡性能与准确性？",
    "reference": "算法上，根据应用需求选择精度（如FP32用于普通计算，FP16用于ConvNets推理，FP64用于高精度计算）；CUDA编程中，使用对应精度的变量和指令，如FP16的half类型，配合Tensor Cores，核心代码：\nglobal void gemm_fp16_kernel(half* M, half* N, half* P, int M_rows, int K, int N_cols) {\n    // 使用half精度变量\n    half Pvalue = __float2half(0.0f);\n    int Row = blockIdx.y * blockDim.y + threadIdx.y;\n    int Col = blockIdx.x * blockDim.x + threadIdx.x;\n    if (Row < M_rows && Col < N_cols) {\n        for (int k = 0; k < K; k++) {\n            Pvalue = __hadd(Pvalue, __hmul(M[RowK + k], N[kN_cols + Col]));\n        }\n        P[Row*N_cols + Col] = Pvalue;\n    }\n}\nFP16精度可提升内存带宽和计算吞吐量，同时满足多数应用的准确性要求。\n三、难题（16道，含Triton、TileLang、PTX编程）",
    "prediction": "算法上，根据应用需求选择精度（如FP32用于普通计算，FP16用于ConvNets推理，FP64用于高精度计算）；CUDA编程中，使用对应精度的变量和指令，如FP16的half类型，配合Tensor Cores，核心代码：\nglobal void gemm_fp16_kernel(half* M, half* N, half* P, int M_rows, int K, int N_cols) {\n    // 使用half精度变量\n    half Pvalue = __float2half(0.0f);\n    int Row = blockIdx.y * blockDim.y + threadIdx.y;\n    int Col = blockIdx.x * blockDim.x + threadIdx.x;\n    if (Row < M_rows && Col < N_cols) {\n        for",
    "rougeL_f1": 0.8082191780821918
  },
  {
    "question": "如何用Triton实现ConvNets的3×3卷积层，并通过自动分块优化提升性能？",
    "reference": "Triton通过Python-like语法定义内核，自动处理分块、内存布局优化，无需手动管理共享内存。实现步骤：1. 定义输入（x）、权重（w）、输出（y）的张量布局，指定块大小（block_size）；2. 使用triton.jit装饰器标记内核，启用自动分块；3. 在内核中通过指针算术实现滑动窗口卷积，Triton编译器自动将输入和权重分块到共享内存，优化内存局部性。核心代码：\nimport triton\nimport triton.language as tl\n@triton.jit\ndef conv3x3_kernel(\n    x_ptr, w_ptr, y_ptr,\n    x_stride, y_stride,\n    kernel_size: tl.constexpr,\n    block_size: tl.constexpr\n):\n    # 线程映射到输出元素\n    row = tl.program_id(0) * block_size + tl.thread_id(0)\n    col = tl.program_id(1) * block_size + tl.thread_id(1)\n    # 初始化累加器\n    y_val = tl.float32(0.0)\n    # 滑动窗口卷积\n    for k in tl.range(0, kernel_size):\n        for l in tl.range(0, kernel_size):\n            # 计算输入索引，处理边界\n            x_row = row + k - kernel_size//2\n            x_col = col + l - kernel_size//2\n            x_val = tl.load(x_ptr + x_row * x_stride + x_col, mask=(x_row >=0) & (x_row < tl.shape(x_ptr)[0]) & (x_col >=0) & (x_col < tl.shape(x_ptr)[1]), other=0.0)\n            w_val = tl.load(w_ptr + k * kernel_size + l)\n            y_val += x_val * w_val\n    # 存储输出\n    tl.store(y_ptr + row * y_stride + col, y_val, mask=(row < tl.shape(y_ptr)[0]) & (col < tl.shape(y_ptr)[1]))\n调用内核\nblock_size = 16\ngrid = (triton.cdiv(height, block_size), triton.cdiv(width, block_size))\nconv3x3_kernel[grid](x, w, y, x.stride(0), y.stride(0), kernel_size=3, block_size=block_size)\nTriton的自动分块优化可匹配甚至超越手工CUDA实现，尤其适合快速迭代卷积层架构。",
    "prediction": "Triton通过Python-like语法定义内核，自动处理分块、内存布局优化，无需手动管理共享内存。实现步骤：1. 定义输入（x）、权重（w）、输出（y）的张量布局，指定块大小（block_size）；2. 使用triton.jit装饰器标记内核，启用自动分块；3. 在内核中通过指针算术实现滑动窗口卷积，Triton编译器自动将输入和权重分块到共享内存，优化内存局部性。核心代码：\nimport triton\nimport triton.language as tl\n@triton.jit\ndef conv3x3_kernel(\n    x_ptr, w_ptr, y_ptr,\n    x_stride, y_stride",
    "rougeL_f1": 0.2903225806451613
  },
  {
    "question": "如何用TileLang优化SpMV算子的CSR格式访问，提升非合并内存访问效率？",
    "reference": "TileLang是领域特定语言，专注于张量和稀疏计算优化，通过声明式语法指定分块和访问模式。实现步骤：1. 定义CSR格式的稀疏矩阵类型和向量类型；2. 声明分块策略（如按行分块，块大小为64）；3. 指定访问模式为“行内连续访问”，TileLang编译器自动优化内存布局和线程映射，减少非合并访问。核心代码：\n// TileLang代码\ntype CSRMatrix<T> = {\n    row_ptr: [Int32],\n    col_ind: [Int32],\n    val: [T],\n    shape: (Int32, Int32)\n}\ntype Vector<T> = [T]\n@tile\ndef spmv(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    let (n_rows, n_cols) = A.shape;\n    let y: Vector<Float32> = zeros(n_rows);\n    // 按行分块，块大小64\n    @tile(size=64)\n    for row in 0..n_rows-1 {\n        let start = A.row_ptr[row];\n        let end = A.row_ptr[row+1];\n        // 行内连续访问非零元素\n        @access(pattern=\"contiguous\")\n        for idx in start..end-1 {\n            let col = A.col_ind[idx];\n            let val = A.val[idx];\n            y[row] += val * x[col];\n        }\n    }\n    return y;\n}\nTileLang编译器会分析访问模式，将行内非零元素按连续内存地址重排，或通过硬件预取优化，提升非合并访问的有效带宽，进而提升SpMV算子性能。",
    "prediction": "TileLang是领域特定语言，专注于张量和稀疏计算优化，通过声明式语法指定分块和访问模式。实现步骤：1. 定义CSR格式的稀疏矩阵类型和向量类型；2. 声明分块策略（如按行分块，块大小为64）；3. 指定访问模式为“行内连续访问”，TileLang编译器自动优化内存布局和线程映射，减少非合并访问。核心代码：\n// TileLang代码\ntype CSRMatrix<T> = {\n    row_ptr: [Int32],\n    col_ind: [Int32],\n    val: [T],\n    shape: (Int32, Int32)\n}\ntype Vector<T",
    "rougeL_f1": 0.3875968992248062
  },
  {
    "question": "Triton实现的矩阵乘法算子如何与CUDA的tiled实现对比，优势在哪里？",
    "reference": "Triton实现无需手动管理共享内存、线程块配置和合并访问，编译器自动优化；CUDA tiled实现需手动设计分块大小、共享内存数组和索引计算。Triton优势：1. 自动分块适配不同GPU架构（如A100、RTX 3090），无需修改代码；2. 自动处理内存合并访问和bank冲突；3. 支持动态块大小调整，适配不同矩阵尺寸；4. 代码简洁，开发效率高。示例Triton矩阵乘法代码：\n@triton.jit\ndef gemm_kernel(A, B, C, M, K, N, stride_am, stride_ak, stride_bk, stride_bn, stride_cm, stride_cn, BLOCK_SIZE: tl.constexpr):\n    # 自动分块和线程映射\n    pid = tl.program_id(0)\n    block_idx_m = pid // (N // BLOCK_SIZE)\n    block_idx_n = pid % (N // BLOCK_SIZE)\n    # 加载块到寄存器\n    a_block = tl.load(A + block_idx_m * BLOCK_SIZE * stride_am + tl.arange(0, BLOCK_SIZE)[:, None] * stride_am + tl.arange(0, BLOCK_SIZE)[None, :] * stride_ak)\n    b_block = tl.load(B + tl.arange(0, BLOCK_SIZE)[:, None] * stride_bk + block_idx_n * BLOCK_SIZE * stride_bn + tl.arange(0, BLOCK_SIZE)[None, :] * stride_bn)\n    # 矩阵乘法\n    c_block = tl.dot(a_block, b_block)\n    # 存储结果\n    tl.store(C + block_idx_m * BLOCK_SIZE * stride_cm + tl.arange(0, BLOCK_SIZE)[:, None] * stride_cm + block_idx_n * BLOCK_SIZE * stride_cn + tl.arange(0, BLOCK_SIZE)[None, :] * stride_cn, c_block)\n相比CUDA手动实现，Triton代码行数减少80%以上，性能损失通常在10%以内，开发效率大幅提升。",
    "prediction": "Triton实现无需手动管理共享内存、线程块配置和合并访问，编译器自动优化；CUDA tiled实现需手动设计分块大小、共享内存数组和索引计算。Triton优势：1. 自动分块适配不同GPU架构（如A100、RTX 3090），无需修改代码；2. 自动处理内存合并访问和bank冲突；3. 支持动态块大小调整，适配不同矩阵尺寸；4. 代码简洁，开发效率高。示例Triton矩阵乘法代码：\n@triton.jit\ndef gemm_kernel(A, B, C, M, K, N, stride_am, stride_ak, stride_bk, stride_bn,",
    "rougeL_f1": 0.336734693877551
  },
  {
    "question": "如何用TileLang实现2D卷积的tiled优化，自动处理halo细胞加载？",
    "reference": "TileLang通过@halo注解声明halo细胞大小，编译器自动生成halo加载代码，无需手动计算halo索引。实现步骤：1. 定义输入、权重、输出张量；2. 用@tile指定输出分块大小，@halo指定halo细胞尺寸（如上下左右各1个）；3. 编写卷积计算逻辑，TileLang自动加载核心细胞和halo细胞。核心代码：\n// TileLang代码\ntype Tensor2D<T> = {\n    data: [T],\n    width: Int32,\n    height: Int32,\n    pitch: Int32\n}\n@tile\ndef conv2d_tiled(x: Tensor2D<Float32>, w: Tensor2D<Float32>, mask_size: Int32) -> Tensor2D<Float32> {\n    let halo = (mask_size - 1) // 2;\n    let tile_size = 16;\n    // 输出分块，每个块带halo细胞\n    @tile(size=tile_size, halo=(halo, halo))\n    for row in 0..x.height-1 {\n        @tile(size=tile_size, halo=(halo, halo))\n        for col in 0..x.width-1 {\n            let y_val: Float32 = 0.0;\n            for k in 0..mask_size-1 {\n                for l in 0..mask_size-1 {\n                    // 自动访问halo细胞，无需手动判断边界\n                    let x_val = x.data[(row + k - halo) * x.pitch + (col + l - halo)];\n                    let w_val = w.data[k * mask_size + l];\n                    y_val += x_val * w_val;\n                }\n            }\n            // 存储输出块核心细胞\n            output.data[row * output.pitch + col] = y_val;\n        }\n    }\n    return output;\n}\nTileLang编译器自动生成halo细胞的加载代码，处理边界条件，同时优化分块内的内存访问，大幅简化tiled卷积的实现复杂度。",
    "prediction": "TileLang通过@halo注解声明halo细胞大小，编译器自动生成halo加载代码，无需手动计算halo索引。实现步骤：1. 定义输入、权重、输出张量；2. 用@tile指定输出分块大小，@halo指定halo细胞尺寸（如上下左右各1个）；3. 编写卷积计算逻辑，TileLang自动加载核心细胞和halo细胞。核心代码：\n// TileLang代码\ntype Tensor2D<T> = {\n    data: [T],\n    width: Int32,\n    height: Int32,\n    pitch: Int32\n}\n@tile\ndef conv2d_tiled(x: Tensor2D<Float32>,",
    "rougeL_f1": 0.37714285714285717
  },
  {
    "question": "Triton实现的ConvNets反向传播算子，如何利用自动微分和内存复用提升性能？",
    "reference": "Triton结合PyTorch的自动微分框架，可自动生成梯度计算内核，同时通过内存复用减少中间数据存储。实现步骤：1. 用Triton定义前向卷积内核；2. 借助PyTorch的torch.autograd.Function封装前向和反向传播；3. 反向传播中复用前向的输入和权重分块缓存，避免重复加载。核心代码片段：\nclass TritonConv2d(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x, w):\n        # 前向传播，调用Triton卷积内核\n        y = triton_conv2d_forward(x, w)\n        # 保存中间数据用于反向传播\n        ctx.save_for_backward(x, w)\n        return y\n    @staticmethod\n    def backward(ctx, grad_y):\n        x, w = ctx.saved_tensors\n        # 反向传播，调用Triton梯度内核，复用前向分块缓存\n        grad_x = triton_conv2d_backward_input(x, w, grad_y)\n        grad_w = triton_conv2d_backward_weight(x, w, grad_y)\n        return grad_x, grad_w\n自动微分调用\nx = torch.randn(1, 3, 256, 256).cuda()\nw = torch.randn(64, 3, 3, 3).cuda()\nconv = TritonConv2d.apply\ny = conv(x, w)\ny.sum().backward()\nTriton的自动微分支持减少手动编写梯度内核的工作量，内存复用优化减少中间数据的全局内存存储和访问，提升反向传播性能。",
    "prediction": "Triton结合PyTorch的自动微分框架，可自动生成梯度计算内核，同时通过内存复用减少中间数据存储。实现步骤：1. 用Triton定义前向卷积内核；2. 借助PyTorch的torch.autograd.Function封装前向和反向传播；3. 反向传播中复用前向的输入和权重分块缓存，避免重复加载。核心代码片段：\nclass TritonConv2d(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x, w):\n        # 前向传播，调用Triton卷积内核\n        y = triton_conv2d_forward(x, w)\n        # 保存中间",
    "rougeL_f1": 0.43750000000000006
  },
  {
    "question": "如何用TileLang优化稀疏矩阵转置后的SpMV算子，利用转置后的连续访问模式？",
    "reference": "TileLang通过@transpose注解自动优化转置矩阵的访问模式，结合分块策略提升并行度。实现步骤：1. 定义转置后的稀疏矩阵（如CSC格式）；2. 用@tile指定按列分块，匹配转置后的连续访问；3. 编写SpMV计算逻辑，TileLang自动优化线程映射和内存访问。核心代码：\n// TileLang代码\n@tile\ndef spmv_transposed(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    // 转置矩阵为CSC格式，按列分块\n    let A_t = @transpose(A, format=\"CSC\");\n    let (n_rows, n_cols) = A_t.shape;\n    let y: Vector<Float32> = zeros(n_rows);\n    // 按列分块，块大小64\n    @tile(size=64, dim=1)\n    for col in 0..n_cols-1 {\n        let start = A_t.col_ptr[col];\n        let end = A_t.col_ptr[col+1];\n        // 列内连续访问非零元素\n        @access(pattern=\"contiguous\")\n        for idx in start..end-1 {\n            let row = A_t.row_ind[idx];\n            let val = A_t.val[idx];\n            y[row] += val * x[col];\n        }\n    }\n    return y;\n}\n转置后的CSC格式让列内非零元素连续存储，TileLang的按列分块和连续访问优化，使线程访问触发合并访问，大幅提升内存效率，相比原CSR格式的SpMV算子性能提升30%-50%。",
    "prediction": "TileLang通过@transpose注解自动优化转置矩阵的访问模式，结合分块策略提升并行度。实现步骤：1. 定义转置后的稀疏矩阵（如CSC格式）；2. 用@tile指定按列分块，匹配转置后的连续访问；3. 编写SpMV计算逻辑，TileLang自动优化线程映射和内存访问。核心代码：\n// TileLang代码\n@tile\ndef spmv_transposed(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    // 转置矩阵为CSC格式，按列分块\n    let A_t = @transpose(A, format=\"CSC\");\n    let (n",
    "rougeL_f1": 0.45714285714285713
  },
  {
    "question": "Triton与CUDA的SpMV算子在处理大规模稀疏矩阵时，性能差异的主要原因是什么？",
    "reference": "主要原因在于内存访问优化和调度开销：1. Triton的自动分块和预取优化更适配大规模矩阵的非零元素分布，可动态调整分块大小，减少内存事务；2. Triton的线程调度由编译器优化，减少CUDA手动实现中的调度冗余（如线程块空闲）；3. Triton支持更灵活的精度调整（如TF32），在大规模计算中提升吞吐量；4. 大规模矩阵下，Triton的自动内存复用减少中间数据存储，降低全局内存带宽压力。例如处理1000万行、非零元素密度1%的稀疏矩阵，Triton实现的性能通常比未优化的CUDA实现高20%-40%，接近手工优化的CUDA实现，但开发效率提升数倍。",
    "prediction": "主要原因在于内存访问优化和调度开销：1. Triton的自动分块和预取优化更适配大规模矩阵的非零元素分布，可动态调整分块大小，减少内存事务；2. Triton的线程调度由编译器优化，减少CUDA手动实现中的调度冗余（如线程块空闲）；3. Triton支持更灵活的精度调整（如TF32），在大规模计算中提升吞吐量；4. 大规模矩阵下，Triton的自动内存复用减少中间数据存储，降低全局内存带宽压力。例如处理1000万行、非零元素密度1%的稀疏矩阵，Triton实现的性能通常比未优化的CUDA",
    "rougeL_f1": 0.9032258064516129
  },
  {
    "question": "如何用TileLang实现ConvNets的深度卷积（Depthwise Convolution），优化组内内存局部性？",
    "reference": "深度卷积将输入通道与输出通道一一对应，组内卷积独立计算，TileLang通过@group注解指定通道分组，优化组内数据复用。实现步骤：1. 定义输入（多通道）、深度卷积核（单通道输入、单通道输出）；2. 用@group按通道分组（每组1个输入通道、1个输出通道）；3. 编写组内卷积逻辑，TileLang自动优化组内数据的共享内存存储。核心代码：\n// TileLang代码\n@tile\ndef depthwise_conv(x: Tensor4D<Float32>, w: Tensor4D<Float32>, kernel_size: Int32) -> Tensor4D<Float32> {\n    let (batch, in_channels, height, width) = x.shape;\n    let (out_channels, _, _, _) = w.shape;\n    assert(in_channels == out_channels); // 深度卷积通道数一致\n    let y: Tensor4D<Float32> = zeros((batch, out_channels, height, width));\n    // 按通道分组，每组1个输入+1个输出通道\n    @group(dim=1, size=1)\n    for c in 0..in_channels-1 {\n        @tile(size=16, dim=2)\n        for row in 0..height-1 {\n            @tile(size=16, dim=3)\n            for col in 0..width-1 {\n                let y_val: Float32 = 0.0;\n                for k in 0..kernel_size-1 {\n                    for l in 0..kernel_size-1 {\n                        let x_row = row + k - kernel_size//2;\n                        let x_col = col + l - kernel_size//2;\n                        let x_val = x.data[batch][c][x_row][x_col] if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) else 0.0;\n                        let w_val = w.data[c][0][k][l];\n                        y_val += x_val * w_val;\n                    }\n                }\n                y.data[batch][c][row][col] = y_val;\n            }\n        }\n    }\n    return y;\n}\nTileLang的通道分组优化让组内数据集中存储，减少共享内存访问冲突，提升组内数据复用率，深度卷积性能比普通卷积提升2-3倍，适合移动设备和边缘计算场景。",
    "prediction": "深度卷积将输入通道与输出通道一一对应，组内卷积独立计算，TileLang通过@group注解指定通道分组，优化组内数据复用。实现步骤：1. 定义输入（多通道）、深度卷积核（单通道输入、单通道输出）；2. 用@group按通道分组（每组1个输入通道、1个输出通道）；3. 编写组内卷积逻辑（如@tile指定分块大小）。核心代码：\n// TileLang代码\n@tile\ndef depthwise_conv(x: Tensor4D<Float32>, w: Tensor4D<Float32>, kernel_size: Int32) -> Tensor4D<Float32> {\n    let (",
    "rougeL_f1": 0.24271844660194172
  },
  {
    "question": "CUDA中矩阵乘法算子如何利用共享内存减少全局内存访问？",
    "reference": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "prediction": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构中SM的资源分配如何限制矩阵乘法算子的并行度？",
    "reference": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "prediction": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过线程索引映射实现1D输入的元素访问？",
    "reference": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "prediction": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp divergence为何会影响卷积算子的边界处理性能？",
    "reference": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "prediction": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子基于CSR格式时，线程如何映射到矩阵非零元素？",
    "reference": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "prediction": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的全局内存合并访问对SpMV算子性能有何影响？",
    "reference": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，提升内存访问效率，进而提升SpMV算子吞吐量。",
    "prediction": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，减少内存事务数量，提升带宽利用率，进而提升SpMV算子吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积神经网络卷积层算子中，如何使用常量内存存储卷积核？",
    "reference": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "prediction": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何影响tiled矩阵乘法性能？",
    "reference": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "prediction": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子如何处理边界的“幽灵细胞”？",
    "reference": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "prediction": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存对稀疏矩阵向量乘法（SpMV）有何优化作用？",
    "reference": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "prediction": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过线程块维度设置提升并行效率？",
    "reference": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "prediction": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，线程块的TILE_SIZE选择需考虑哪些GPU架构限制？",
    "reference": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "prediction": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SIMD硬件如何提升ConvNets卷积层的计算吞吐量？",
    "reference": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "prediction": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过填充优化（Padding）提升内存访问效率？",
    "reference": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "prediction": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽瓶颈为何对矩阵乘法算子影响显著？",
    "reference": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "prediction": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何使用自动变量（寄存器）提升计算速度？",
    "reference": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "prediction": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM多线程调度如何隐藏矩阵乘法算子的内存延迟？",
    "reference": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "prediction": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子如何将2D输入线性化以适配全局内存存储？",
    "reference": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i]，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "prediction": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存缓存对卷积核访问有何优化？",
    "reference": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "prediction": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的线程块大小选择需匹配哪些GPU架构参数？",
    "reference": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "prediction": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过边界检查处理非TILE_WIDTH倍数的矩阵？",
    "reference": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH=256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "prediction": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH为256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存带宽比全局内存高多少，对卷积算子有何意义？",
    "reference": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "prediction": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何复用前向传播的中间数据？",
    "reference": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "prediction": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp大小（32线程）如何影响卷积算子的线程块设计？",
    "reference": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "prediction": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrVal数组，如何确保线程访问的合并性？",
    "reference": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "prediction": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，__syncthreads()的作用是什么？",
    "reference": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "prediction": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多通道内存（如GDDR6）如何提升矩阵乘法算子的带宽？",
    "reference": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "prediction": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的掩码（Mask）存储在常量内存的优势是什么？",
    "reference": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "prediction": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM核心数如何影响ConvNets卷积层的计算速度？",
    "reference": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "prediction": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理行数远大于线程块数的稀疏矩阵？",
    "reference": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "prediction": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，TILE_WIDTH选择为16或32的依据是什么？",
    "reference": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "prediction": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存对齐要求如何影响卷积算子的输入数据存储？",
    "reference": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "prediction": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何处理多通道输入（如RGB图像）？",
    "reference": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "prediction": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存对矩阵乘法算子的tiling优化有何补充？",
    "reference": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "prediction": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrColInd数组，为何需要与csrVal数组一一对应？",
    "reference": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "prediction": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过循环展开提升指令执行效率？",
    "reference": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "prediction": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的功耗限制如何影响卷积算子的性能调优？",
    "reference": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "prediction": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Pvalue累加变量为何要声明为volatile？",
    "reference": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "prediction": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的异步执行如何提升SpMV算子的整体吞吐量？",
    "reference": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "prediction": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的输出数组P，如何分配全局内存以避免内存碎片？",
    "reference": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "prediction": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何在SpMV算子中避免？",
    "reference": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "prediction": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何计算卷积核的梯度？",
    "reference": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "prediction": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的计算能力（如Compute Capability 8.6）对矩阵乘法算子有何影响？",
    "reference": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "prediction": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理空行（无非零元素的矩阵行）？",
    "reference": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则线程跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "prediction": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则线程跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaMemcpyToSymbol的作用是什么？",
    "reference": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "prediction": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存控制器数量如何影响SpMV算子的带宽？",
    "reference": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "prediction": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的线程块维度（如dim3(16,16)）为何选择二维？",
    "reference": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "prediction": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp调度器如何选择就绪warp执行？",
    "reference": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已加载完成的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "prediction": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已加载完成的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子的halo细胞加载，如何避免线程冗余计算？",
    "reference": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "prediction": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存容量限制（64KB）如何影响ConvNets的大尺寸卷积核？",
    "reference": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "prediction": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的输出向量初始化为何要使用cudaMemset？",
    "reference": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "prediction": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过blockDim和gridDim计算总线程数？",
    "reference": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "prediction": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存一致性对多SM执行SpMV算子有何意义？",
    "reference": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "prediction": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中卷积算子的__shared__变量声明为何要指定大小？",
    "reference": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "prediction": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的张量核心（Tensor Cores）如何提升ConvNets卷积层性能？",
    "reference": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "prediction": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrRowPtr数组为何要比矩阵行数多1？",
    "reference": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "prediction": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何处理浮点数溢出？",
    "reference": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "prediction": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽与计算吞吐量的比例（如1TB/s带宽、10TFLOPS计算）如何影响卷积算子？",
    "reference": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "prediction": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何实现零填充（Zero Padding）？",
    "reference": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "prediction": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM调度器如何分配线程块到SM？",
    "reference": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "prediction": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过线程私有化提升性能？",
    "reference": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "prediction": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaGetDeviceProperties的作用是什么？",
    "reference": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "prediction": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多进程并发对SpMV算子有何影响？",
    "reference": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "prediction": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Nds[ty][tx] = N[(ph*TILE_WIDTH + ty)*Width + Col]索引计算的含义是什么？",
    "reference": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "prediction": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存写回策略对卷积算子有何影响？",
    "reference": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "prediction": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的__device__函数作用是什么？",
    "reference": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "prediction": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何通过im2col转换提升性能？",
    "reference": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "prediction": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA编程，tiled矩阵乘法算子如何通过数据复用提升计算/内存访问比？",
    "reference": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累加 ... }。",
    "prediction": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累",
    "rougeL_f1": 1.0
  },
  {
    "question": "算法层面如何优化SpMV算子的负载均衡，CUDA编程如何实现该优化？",
    "reference": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "prediction": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，2D卷积算子如何通过分块大小选择平衡共享内存占用与并行度？",
    "reference": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "prediction": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "rougeL_f1": 1.0
  },
  {
    "question": "ConvNets的卷积层算法如何转换为矩阵乘法，CUDA编程如何高效实现该转换？",
    "reference": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int channel = blockIdx.z;\n    if (row < height && col < width) {\n        int idx = channel * height * width + row * width + col;\n        // 展开卷积窗口到x_col\n        for (int k = 0; k < kernel_size; k++) {\n            for (int l = 0; l < kernel_size; l++) {\n                int x_row = row + k - kernel_size/2;\n                int x_col = col + l - kernel_size/2;\n                if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n                    x_col[col * kernel_sizekernel_size + kkernel_size + l] = x[channel * height * width + x_row * width + x_col];\n                }\n            }\n        }\n    }\n}\n之后调用GEMM内核完成矩阵乘法，利用矩阵乘法的优化特性提升卷积性能。",
    "prediction": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y",
    "rougeL_f1": 0.5029940119760479
  },
  {
    "question": "算法层面如何处理稀疏矩阵的转置以优化SpMV算子，CUDA编程如何实现转置？",
    "reference": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_csrVal, int n) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < n) {\n        for (int i = csrRowPtr[row]; i < csrRowPtr[row+1]; i++) {\n            int col = csrColInd[i];\n            float val = csrVal[i];\n            int pos = atomicAdd(&t_csrRowPtr[col+1], 1);\n            t_csrColInd[pos] = row;\n            t_csrVal[pos] = val;\n        }\n    }\n}\n转置后SpMV算子的内存访问更易合并，提升性能。",
    "prediction": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_c",
    "rougeL_f1": 0.5535714285714286
  },
  {
    "question": "结合算法与CUDA，矩阵乘法算子如何通过循环展开提升指令吞吐量？",
    "reference": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE_WIDTH较大的场景。",
    "prediction": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE",
    "rougeL_f1": 0.9841269841269841
  },
  {
    "question": "卷积算子的算法如何通过“ halo 细胞复用”减少数据传输，CUDA编程如何实现？",
    "reference": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "prediction": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "SpMV算子的算法如何通过“行合并”优化，CUDA编程如何实现该优化？",
    "reference": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "prediction": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的反向传播算子如何优化梯度计算的内存访问？",
    "reference": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] += dY_ds[ty][tx] * X_ds[ty][tx];\n通过共享内存优化内存局部性，减少全局内存访问，提升梯度计算速度。",
    "prediction": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] +=",
    "rougeL_f1": 0.9090909090909091
  },
  {
    "question": "矩阵乘法算子的算法如何处理非正方形矩阵，CUDA编程如何调整线程映射？",
    "reference": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0; k < K; k += TILE_K) {\n        // 加载矩形子矩阵\n        Mds[ty][tk] = M[Row*K + k + tk];\n        Nds[tk][tx] = N[(k + tk)N + Col];\n        __syncthreads();\n        // 乘法累加\n        for (int tk = 0; tk < TILE_K; tk++) {\n            Pvalue += Mds[ty][tk] * Nds[tk][tx];\n        }\n    }\n    P[RowN + Col] = Pvalue;\n}\n适配非正方形矩阵的维度，确保计算正确性和性能。",
    "prediction": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0;",
    "rougeL_f1": 0.7248322147651006
  },
  {
    "question": "卷积算子的算法如何通过“多尺度分块”优化，CUDA编程如何实现？",
    "reference": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, width, height, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH - 1]），适配不同输入尺度。",
    "prediction": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, width, height, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH -",
    "rougeL_f1": 0.98989898989899
  },
  {
    "question": "SpMV算子的算法如何通过“原子操作优化”处理输出向量的累加，CUDA编程如何实现？",
    "reference": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "prediction": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的卷积层算子如何优化多通道输入的计算？",
    "reference": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size + l];\n    }\n}\nY[row * width + col] += Pvalue;\n通过三维线程块（gridDim.z=channels）并行处理多通道，提升计算效率。",
    "prediction": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size",
    "rougeL_f1": 0.9291338582677166
  },
  {
    "question": "矩阵乘法算子的算法如何通过“预取”优化内存访问，CUDA编程如何实现？",
    "reference": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next_ph*TILE_WIDTH + ty)*Width + Col];\n    }\n    __syncthreads();\n    // 计算当前子矩阵\n    for (int k = 0; k < TILE_WIDTH; ++k) {\n        Pvalue += Mds0[ty][k] * Nds0[k][tx];\n    }\n    // 切换缓冲\n    swap(Mds0, Mds1);\n    swap(Nds0, Nds1);\n}\n通过计算与预取重叠，减少内存延迟对性能的影响。",
    "prediction": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next",
    "rougeL_f1": 0.7358490566037735
  },
  {
    "question": "卷积算子的算法如何处理“空洞卷积”（Dilated Convolution），CUDA编程如何调整索引计算？",
    "reference": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n            Pvalue += X[x_rowpitch + x_col] * W[kkernel_size + l];\n        }\n    }\n}\n通过k*dilation和l*dilation跳过空洞位置，实现空洞卷积的计算逻辑。",
    "prediction": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width",
    "rougeL_f1": 0.890625
  },
  {
    "question": "SpMV算子的算法如何通过“压缩存储格式转换”（如CSR转ELL）优化，CUDA编程如何实现转换？",
    "reference": "算法上，ELL格式将稀疏矩阵按列存储，每行非零元素填充到固定长度，适合并行访问；CUDA编程中，实现CSR到ELL的转换：1. 统计最大非零元素行数（max_nnz）；2. 初始化ELL格式的col_ind和val数组（维度为n×max_nnz）；3. 线程块处理每行，将非零元素填入ELL数组，核心代码：\nglobal void csr_to_ell_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* ell_col_ind, float* ell_val, int n, int max_nnz) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < n) {\n        for (int i = 0; i < max_nnz; i++) {\n            int idx = csrRowPtr[row] + i;\n            if (idx < csrRowPtr[row+1]) {\n                ell_col_ind[row * max_nnz + i] = csrColInd[idx];\n                ell_val[row * max_nnz + i] = csrVal[idx];\n            } else {\n                ell_col_ind[row * max_nnz + i] = -1; // 标记无效\n                ell_val[row * max_nnz + i] = 0;\n            }\n        }\n    }\n}\nELL格式的SpMV算子可通过线程并行处理每行，提升访问效率。",
    "prediction": "算法上，ELL格式将稀疏矩阵按列存储，每行非零元素填充到固定长度，适合并行访问；CUDA编程中，实现CSR到ELL的转换：1. 统计最大非零元素行数（max_nnz）；2. 初始化ELL格式的col_ind和val数组（维度为n×max_nnz）；3. 线程块处理每行，将非零元素填入ELL数组，核心代码：\nglobal void csr_to_ell_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* ell_col_ind, float* ell_val, int n, int max_nnz) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (",
    "rougeL_f1": 0.6451612903225806
  },
  {
    "question": "结合算法与CUDA，矩阵乘法算子如何通过“精度调整”平衡性能与准确性？",
    "reference": "算法上，根据应用需求选择精度（如FP32用于普通计算，FP16用于ConvNets推理，FP64用于高精度计算）；CUDA编程中，使用对应精度的变量和指令，如FP16的half类型，配合Tensor Cores，核心代码：\nglobal void gemm_fp16_kernel(half* M, half* N, half* P, int M_rows, int K, int N_cols) {\n    // 使用half精度变量\n    half Pvalue = __float2half(0.0f);\n    int Row = blockIdx.y * blockDim.y + threadIdx.y;\n    int Col = blockIdx.x * blockDim.x + threadIdx.x;\n    if (Row < M_rows && Col < N_cols) {\n        for (int k = 0; k < K; k++) {\n            Pvalue = __hadd(Pvalue, __hmul(M[RowK + k], N[kN_cols + Col]));\n        }\n        P[Row*N_cols + Col] = Pvalue;\n    }\n}\nFP16精度可提升内存带宽和计算吞吐量，同时满足多数应用的准确性要求。\n三、难题（16道，含Triton、TileLang、PTX编程）",
    "prediction": "算法上，根据应用需求选择精度（如FP32用于普通计算，FP16用于ConvNets推理，FP64用于高精度计算）；CUDA编程中，使用对应精度的变量和指令，如FP16的half类型，配合Tensor Cores，核心代码：\nglobal void gemm_fp16_kernel(half* M, half* N, half* P, int M_rows, int K, int N_cols) {\n    // 使用half精度变量\n    half Pvalue = __float2half(0.0f);\n    int Row = blockIdx.y * blockDim.y + threadIdx.y;\n    int Col = blockIdx.x * blockDim.x + threadIdx.x;\n    if (Row < M_rows && Col < N_cols) {\n        for",
    "rougeL_f1": 0.8082191780821918
  },
  {
    "question": "如何用Triton实现ConvNets的3×3卷积层，并通过自动分块优化提升性能？",
    "reference": "Triton通过Python-like语法定义内核，自动处理分块、内存布局优化，无需手动管理共享内存。实现步骤：1. 定义输入（x）、权重（w）、输出（y）的张量布局，指定块大小（block_size）；2. 使用triton.jit装饰器标记内核，启用自动分块；3. 在内核中通过指针算术实现滑动窗口卷积，Triton编译器自动将输入和权重分块到共享内存，优化内存局部性。核心代码：\nimport triton\nimport triton.language as tl\n@triton.jit\ndef conv3x3_kernel(\n    x_ptr, w_ptr, y_ptr,\n    x_stride, y_stride,\n    kernel_size: tl.constexpr,\n    block_size: tl.constexpr\n):\n    # 线程映射到输出元素\n    row = tl.program_id(0) * block_size + tl.thread_id(0)\n    col = tl.program_id(1) * block_size + tl.thread_id(1)\n    # 初始化累加器\n    y_val = tl.float32(0.0)\n    # 滑动窗口卷积\n    for k in tl.range(0, kernel_size):\n        for l in tl.range(0, kernel_size):\n            # 计算输入索引，处理边界\n            x_row = row + k - kernel_size//2\n            x_col = col + l - kernel_size//2\n            x_val = tl.load(x_ptr + x_row * x_stride + x_col, mask=(x_row >=0) & (x_row < tl.shape(x_ptr)[0]) & (x_col >=0) & (x_col < tl.shape(x_ptr)[1]), other=0.0)\n            w_val = tl.load(w_ptr + k * kernel_size + l)\n            y_val += x_val * w_val\n    # 存储输出\n    tl.store(y_ptr + row * y_stride + col, y_val, mask=(row < tl.shape(y_ptr)[0]) & (col < tl.shape(y_ptr)[1]))\n调用内核\nblock_size = 16\ngrid = (triton.cdiv(height, block_size), triton.cdiv(width, block_size))\nconv3x3_kernel[grid](x, w, y, x.stride(0), y.stride(0), kernel_size=3, block_size=block_size)\nTriton的自动分块优化可匹配甚至超越手工CUDA实现，尤其适合快速迭代卷积层架构。",
    "prediction": "Triton通过Python-like语法定义内核，自动处理分块、内存布局优化，无需手动管理共享内存。实现步骤：1. 定义输入（x）、权重（w）、输出（y）的张量布局，指定块大小（block_size）；2. 使用triton.jit装饰器标记内核，启用自动分块；3. 在内核中通过指针算术实现滑动窗口卷积，Triton编译器自动将输入和权重分块到共享内存，优化内存局部性。核心代码：\nimport triton\nimport triton.language as tl\n@triton.jit\ndef conv3x3_kernel(\n    x_ptr, w_ptr, y_ptr,\n    x_stride, y_stride",
    "rougeL_f1": 0.2903225806451613
  },
  {
    "question": "如何用TileLang优化SpMV算子的CSR格式访问，提升非合并内存访问效率？",
    "reference": "TileLang是领域特定语言，专注于张量和稀疏计算优化，通过声明式语法指定分块和访问模式。实现步骤：1. 定义CSR格式的稀疏矩阵类型和向量类型；2. 声明分块策略（如按行分块，块大小为64）；3. 指定访问模式为“行内连续访问”，TileLang编译器自动优化内存布局和线程映射，减少非合并访问。核心代码：\n// TileLang代码\ntype CSRMatrix<T> = {\n    row_ptr: [Int32],\n    col_ind: [Int32],\n    val: [T],\n    shape: (Int32, Int32)\n}\ntype Vector<T> = [T]\n@tile\ndef spmv(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    let (n_rows, n_cols) = A.shape;\n    let y: Vector<Float32> = zeros(n_rows);\n    // 按行分块，块大小64\n    @tile(size=64)\n    for row in 0..n_rows-1 {\n        let start = A.row_ptr[row];\n        let end = A.row_ptr[row+1];\n        // 行内连续访问非零元素\n        @access(pattern=\"contiguous\")\n        for idx in start..end-1 {\n            let col = A.col_ind[idx];\n            let val = A.val[idx];\n            y[row] += val * x[col];\n        }\n    }\n    return y;\n}\nTileLang编译器会分析访问模式，将行内非零元素按连续内存地址重排，或通过硬件预取优化，提升非合并访问的有效带宽，进而提升SpMV算子性能。",
    "prediction": "TileLang是领域特定语言，专注于张量和稀疏计算优化，通过声明式语法指定分块和访问模式。实现步骤：1. 定义CSR格式的稀疏矩阵类型和向量类型；2. 声明分块策略（如按行分块，块大小为64）；3. 指定访问模式为“行内连续访问”，TileLang编译器自动优化内存布局和线程映射，减少非合并访问。核心代码：\n// TileLang代码\ntype CSRMatrix<T> = {\n    row_ptr: [Int32],\n    col_ind: [Int32],\n    val: [T],\n    shape: (Int32, Int32)\n}\ntype Vector<T",
    "rougeL_f1": 0.3875968992248062
  },
  {
    "question": "Triton实现的矩阵乘法算子如何与CUDA的tiled实现对比，优势在哪里？",
    "reference": "Triton实现无需手动管理共享内存、线程块配置和合并访问，编译器自动优化；CUDA tiled实现需手动设计分块大小、共享内存数组和索引计算。Triton优势：1. 自动分块适配不同GPU架构（如A100、RTX 3090），无需修改代码；2. 自动处理内存合并访问和bank冲突；3. 支持动态块大小调整，适配不同矩阵尺寸；4. 代码简洁，开发效率高。示例Triton矩阵乘法代码：\n@triton.jit\ndef gemm_kernel(A, B, C, M, K, N, stride_am, stride_ak, stride_bk, stride_bn, stride_cm, stride_cn, BLOCK_SIZE: tl.constexpr):\n    # 自动分块和线程映射\n    pid = tl.program_id(0)\n    block_idx_m = pid // (N // BLOCK_SIZE)\n    block_idx_n = pid % (N // BLOCK_SIZE)\n    # 加载块到寄存器\n    a_block = tl.load(A + block_idx_m * BLOCK_SIZE * stride_am + tl.arange(0, BLOCK_SIZE)[:, None] * stride_am + tl.arange(0, BLOCK_SIZE)[None, :] * stride_ak)\n    b_block = tl.load(B + tl.arange(0, BLOCK_SIZE)[:, None] * stride_bk + block_idx_n * BLOCK_SIZE * stride_bn + tl.arange(0, BLOCK_SIZE)[None, :] * stride_bn)\n    # 矩阵乘法\n    c_block = tl.dot(a_block, b_block)\n    # 存储结果\n    tl.store(C + block_idx_m * BLOCK_SIZE * stride_cm + tl.arange(0, BLOCK_SIZE)[:, None] * stride_cm + block_idx_n * BLOCK_SIZE * stride_cn + tl.arange(0, BLOCK_SIZE)[None, :] * stride_cn, c_block)\n相比CUDA手动实现，Triton代码行数减少80%以上，性能损失通常在10%以内，开发效率大幅提升。",
    "prediction": "Triton实现无需手动管理共享内存、线程块配置和合并访问，编译器自动优化；CUDA tiled实现需手动设计分块大小、共享内存数组和索引计算。Triton优势：1. 自动分块适配不同GPU架构（如A100、RTX 3090），无需修改代码；2. 自动处理内存合并访问和bank冲突；3. 支持动态块大小调整，适配不同矩阵尺寸；4. 代码简洁，开发效率高。示例Triton矩阵乘法代码：\n@triton.jit\ndef gemm_kernel(A, B, C, M, K, N, stride_am, stride_ak, stride_bk, stride_bn,",
    "rougeL_f1": 0.336734693877551
  },
  {
    "question": "如何用TileLang实现2D卷积的tiled优化，自动处理halo细胞加载？",
    "reference": "TileLang通过@halo注解声明halo细胞大小，编译器自动生成halo加载代码，无需手动计算halo索引。实现步骤：1. 定义输入、权重、输出张量；2. 用@tile指定输出分块大小，@halo指定halo细胞尺寸（如上下左右各1个）；3. 编写卷积计算逻辑，TileLang自动加载核心细胞和halo细胞。核心代码：\n// TileLang代码\ntype Tensor2D<T> = {\n    data: [T],\n    width: Int32,\n    height: Int32,\n    pitch: Int32\n}\n@tile\ndef conv2d_tiled(x: Tensor2D<Float32>, w: Tensor2D<Float32>, mask_size: Int32) -> Tensor2D<Float32> {\n    let halo = (mask_size - 1) // 2;\n    let tile_size = 16;\n    // 输出分块，每个块带halo细胞\n    @tile(size=tile_size, halo=(halo, halo))\n    for row in 0..x.height-1 {\n        @tile(size=tile_size, halo=(halo, halo))\n        for col in 0..x.width-1 {\n            let y_val: Float32 = 0.0;\n            for k in 0..mask_size-1 {\n                for l in 0..mask_size-1 {\n                    // 自动访问halo细胞，无需手动判断边界\n                    let x_val = x.data[(row + k - halo) * x.pitch + (col + l - halo)];\n                    let w_val = w.data[k * mask_size + l];\n                    y_val += x_val * w_val;\n                }\n            }\n            // 存储输出块核心细胞\n            output.data[row * output.pitch + col] = y_val;\n        }\n    }\n    return output;\n}\nTileLang编译器自动生成halo细胞的加载代码，处理边界条件，同时优化分块内的内存访问，大幅简化tiled卷积的实现复杂度。",
    "prediction": "TileLang通过@halo注解声明halo细胞大小，编译器自动生成halo加载代码，无需手动计算halo索引。实现步骤：1. 定义输入、权重、输出张量；2. 用@tile指定输出分块大小，@halo指定halo细胞尺寸（如上下左右各1个）；3. 编写卷积计算逻辑，TileLang自动加载核心细胞和halo细胞。核心代码：\n// TileLang代码\ntype Tensor2D<T> = {\n    data: [T],\n    width: Int32,\n    height: Int32,\n    pitch: Int32\n}\n@tile\ndef conv2d_tiled(x: Tensor2D<Float32>,",
    "rougeL_f1": 0.37714285714285717
  },
  {
    "question": "Triton实现的ConvNets反向传播算子，如何利用自动微分和内存复用提升性能？",
    "reference": "Triton结合PyTorch的自动微分框架，可自动生成梯度计算内核，同时通过内存复用减少中间数据存储。实现步骤：1. 用Triton定义前向卷积内核；2. 借助PyTorch的torch.autograd.Function封装前向和反向传播；3. 反向传播中复用前向的输入和权重分块缓存，避免重复加载。核心代码片段：\nclass TritonConv2d(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x, w):\n        # 前向传播，调用Triton卷积内核\n        y = triton_conv2d_forward(x, w)\n        # 保存中间数据用于反向传播\n        ctx.save_for_backward(x, w)\n        return y\n    @staticmethod\n    def backward(ctx, grad_y):\n        x, w = ctx.saved_tensors\n        # 反向传播，调用Triton梯度内核，复用前向分块缓存\n        grad_x = triton_conv2d_backward_input(x, w, grad_y)\n        grad_w = triton_conv2d_backward_weight(x, w, grad_y)\n        return grad_x, grad_w\n自动微分调用\nx = torch.randn(1, 3, 256, 256).cuda()\nw = torch.randn(64, 3, 3, 3).cuda()\nconv = TritonConv2d.apply\ny = conv(x, w)\ny.sum().backward()\nTriton的自动微分支持减少手动编写梯度内核的工作量，内存复用优化减少中间数据的全局内存存储和访问，提升反向传播性能。",
    "prediction": "Triton结合PyTorch的自动微分框架，可自动生成梯度计算内核，同时通过内存复用减少中间数据存储。实现步骤：1. 用Triton定义前向卷积内核；2. 借助PyTorch的torch.autograd.Function封装前向和反向传播；3. 反向传播中复用前向的输入和权重分块缓存，避免重复加载。核心代码片段：\nclass TritonConv2d(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x, w):\n        # 前向传播，调用Triton卷积内核\n        y = triton_conv2d_forward(x, w)\n        # 保存中间",
    "rougeL_f1": 0.43750000000000006
  },
  {
    "question": "如何用TileLang优化稀疏矩阵转置后的SpMV算子，利用转置后的连续访问模式？",
    "reference": "TileLang通过@transpose注解自动优化转置矩阵的访问模式，结合分块策略提升并行度。实现步骤：1. 定义转置后的稀疏矩阵（如CSC格式）；2. 用@tile指定按列分块，匹配转置后的连续访问；3. 编写SpMV计算逻辑，TileLang自动优化线程映射和内存访问。核心代码：\n// TileLang代码\n@tile\ndef spmv_transposed(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    // 转置矩阵为CSC格式，按列分块\n    let A_t = @transpose(A, format=\"CSC\");\n    let (n_rows, n_cols) = A_t.shape;\n    let y: Vector<Float32> = zeros(n_rows);\n    // 按列分块，块大小64\n    @tile(size=64, dim=1)\n    for col in 0..n_cols-1 {\n        let start = A_t.col_ptr[col];\n        let end = A_t.col_ptr[col+1];\n        // 列内连续访问非零元素\n        @access(pattern=\"contiguous\")\n        for idx in start..end-1 {\n            let row = A_t.row_ind[idx];\n            let val = A_t.val[idx];\n            y[row] += val * x[col];\n        }\n    }\n    return y;\n}\n转置后的CSC格式让列内非零元素连续存储，TileLang的按列分块和连续访问优化，使线程访问触发合并访问，大幅提升内存效率，相比原CSR格式的SpMV算子性能提升30%-50%。",
    "prediction": "TileLang通过@transpose注解自动优化转置矩阵的访问模式，结合分块策略提升并行度。实现步骤：1. 定义转置后的稀疏矩阵（如CSC格式）；2. 用@tile指定按列分块，匹配转置后的连续访问；3. 编写SpMV计算逻辑，TileLang自动优化线程映射和内存访问。核心代码：\n// TileLang代码\n@tile\ndef spmv_transposed(A: CSRMatrix<Float32>, x: Vector<Float32>) -> Vector<Float32> {\n    // 转置矩阵为CSC格式，按列分块\n    let A_t = @transpose(A, format=\"CSC\");\n    let (n",
    "rougeL_f1": 0.45714285714285713
  },
  {
    "question": "Triton与CUDA的SpMV算子在处理大规模稀疏矩阵时，性能差异的主要原因是什么？",
    "reference": "主要原因在于内存访问优化和调度开销：1. Triton的自动分块和预取优化更适配大规模矩阵的非零元素分布，可动态调整分块大小，减少内存事务；2. Triton的线程调度由编译器优化，减少CUDA手动实现中的调度冗余（如线程块空闲）；3. Triton支持更灵活的精度调整（如TF32），在大规模计算中提升吞吐量；4. 大规模矩阵下，Triton的自动内存复用减少中间数据存储，降低全局内存带宽压力。例如处理1000万行、非零元素密度1%的稀疏矩阵，Triton实现的性能通常比未优化的CUDA实现高20%-40%，接近手工优化的CUDA实现，但开发效率提升数倍。",
    "prediction": "主要原因在于内存访问优化和调度开销：1. Triton的自动分块和预取优化更适配大规模矩阵的非零元素分布，可动态调整分块大小，减少内存事务；2. Triton的线程调度由编译器优化，减少CUDA手动实现中的调度冗余（如线程块空闲）；3. Triton支持更灵活的精度调整（如TF32），在大规模计算中提升吞吐量；4. 大规模矩阵下，Triton的自动内存复用减少中间数据存储，降低全局内存带宽压力。例如处理1000万行、非零元素密度1%的稀疏矩阵，Triton实现的性能通常比未优化的CUDA",
    "rougeL_f1": 0.9032258064516129
  },
  {
    "question": "如何用TileLang实现ConvNets的深度卷积（Depthwise Convolution），优化组内内存局部性？",
    "reference": "深度卷积将输入通道与输出通道一一对应，组内卷积独立计算，TileLang通过@group注解指定通道分组，优化组内数据复用。实现步骤：1. 定义输入（多通道）、深度卷积核（单通道输入、单通道输出）；2. 用@group按通道分组（每组1个输入通道、1个输出通道）；3. 编写组内卷积逻辑，TileLang自动优化组内数据的共享内存存储。核心代码：\n// TileLang代码\n@tile\ndef depthwise_conv(x: Tensor4D<Float32>, w: Tensor4D<Float32>, kernel_size: Int32) -> Tensor4D<Float32> {\n    let (batch, in_channels, height, width) = x.shape;\n    let (out_channels, _, _, _) = w.shape;\n    assert(in_channels == out_channels); // 深度卷积通道数一致\n    let y: Tensor4D<Float32> = zeros((batch, out_channels, height, width));\n    // 按通道分组，每组1个输入+1个输出通道\n    @group(dim=1, size=1)\n    for c in 0..in_channels-1 {\n        @tile(size=16, dim=2)\n        for row in 0..height-1 {\n            @tile(size=16, dim=3)\n            for col in 0..width-1 {\n                let y_val: Float32 = 0.0;\n                for k in 0..kernel_size-1 {\n                    for l in 0..kernel_size-1 {\n                        let x_row = row + k - kernel_size//2;\n                        let x_col = col + l - kernel_size//2;\n                        let x_val = x.data[batch][c][x_row][x_col] if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) else 0.0;\n                        let w_val = w.data[c][0][k][l];\n                        y_val += x_val * w_val;\n                    }\n                }\n                y.data[batch][c][row][col] = y_val;\n            }\n        }\n    }\n    return y;\n}\nTileLang的通道分组优化让组内数据集中存储，减少共享内存访问冲突，提升组内数据复用率，深度卷积性能比普通卷积提升2-3倍，适合移动设备和边缘计算场景。",
    "prediction": "深度卷积将输入通道与输出通道一一对应，组内卷积独立计算，TileLang通过@group注解指定通道分组，优化组内数据复用。实现步骤：1. 定义输入（多通道）、深度卷积核（单通道输入、单通道输出）；2. 用@group按通道分组（每组1个输入通道、1个输出通道）；3. 编写组内卷积逻辑，TileLang自动优化组内数据的共享内存存储。核心代码：\n// TileLang代码\n@tile\ndef depthwise_conv(x: Tensor4D<Float32>, w: Tensor4D<Float32>, kernel_size: Int32) -> Tensor4D<Float32>",
    "rougeL_f1": 0.24390243902439027
  },
  {
    "question": "CUDA中矩阵乘法算子如何利用共享内存减少全局内存访问？",
    "reference": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "prediction": "通过tiling技术将输入矩阵划分为TILE_WIDTH×TILE_WIDTH子矩阵，线程块协作将子矩阵加载到__shared__修饰的共享内存数组（如Mds、Nds）。后续计算通过访问低延迟、高带宽的共享内存复用数据，而非重复访问全局内存。例如核心代码Mds[ty][tx] = M[Row*Width + ph*TILE_WIDTH + tx];，让每个输入元素被多次使用，大幅降低全局内存带宽压力。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构中SM的资源分配如何限制矩阵乘法算子的并行度？",
    "reference": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "prediction": "每个SM的寄存器、共享内存容量有限。矩阵乘法算子中，若每个线程使用过多寄存器（如自动变量过多），或共享内存数组过大（如TILE_WIDTH设置过大），会导致SM可同时调度的线程块数量减少。例如Fermi架构SM有16384个寄存器，若每个线程用12个寄存器，16×16线程块需3072个寄存器，SM最多只能同时调度5个块，降低并行效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过线程索引映射实现1D输入的元素访问？",
    "reference": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "prediction": "采用int i = blockIdx.x*blockDim.x + threadIdx.x映射线程到输出元素索引，再通过int N_start_point = i - (Mask_Width/2)计算输入起始索引，循环遍历掩码宽度内的输入元素完成加权和。核心逻辑为线程与输出元素一一对应，通过索引偏移覆盖邻域输入，确保卷积计算的正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp divergence为何会影响卷积算子的边界处理性能？",
    "reference": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "prediction": "卷积边界线程需判断输入索引是否合法（如if (N_start_point + j >= 0 && N_start_point + j < Width)），导致同一warp内部分线程执行if分支、部分跳过，触发warp序列化执行。GPU架构中warp是最小执行单元，序列化会增加指令周期，边界线程占比越高，性能损失越明显。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子基于CSR格式时，线程如何映射到矩阵非零元素？",
    "reference": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "prediction": "按行分配线程块，每个线程块处理若干矩阵行，线程块内线程处理行内非零元素。通过csrRowPtr数组获取每行非零元素的起始和结束索引，线程通过int idx = threadIdx.x; int row = blockIdx.x * blockDim.y + threadIdx.y;映射到具体行，再通过int col = csrColInd[csrRowPtr[row] + idx]访问非零元素列索引，完成向量乘法。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的全局内存合并访问对SpMV算子性能有何影响？",
    "reference": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，提升内存访问效率，进而提升SpMV算子吞吐量。",
    "prediction": "CSR格式中每行非零元素存储不连续，若线程访问非连续全局内存地址，会导致GPU发起更多内存事务，降低带宽利用率。当实现合并访问（如相邻线程访问连续的csrVal、csrColInd元素），GPU可将多个线程的访问合并为一个事务，减少内存事务数量，提升带宽利用率，进而提升SpMV算子吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积神经网络卷积层算子中，如何使用常量内存存储卷积核？",
    "reference": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "prediction": "在主机端用__constant__ float M[MAX_MASK_WIDTH]声明常量内存数组，通过cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))将卷积核数据从主机复制到设备常量内存。内核中直接访问M数组，GPU会对常量内存进行缓存和广播优化，减少卷积核数据的全局内存访问次数，尤其适合小尺寸卷积核（如3×3、5×5）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何影响tiled矩阵乘法性能？",
    "reference": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "prediction": "共享内存被划分为多个bank（如32个），若多个线程同时访问同一bank的不同地址，会导致冲突并序列化访问。tiled矩阵乘法中，若共享内存数组访问模式为Mds[ty][tx]，当tx为步长访问时（如Mds[ty][k]），易触发bank冲突。通过调整数组维度（如Mds[TILE_WIDTH+1][TILE_WIDTH]）或访问顺序，可避免冲突，提升共享内存访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子如何处理边界的“幽灵细胞”？",
    "reference": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "prediction": "计算输入起始索引N_start_point = i - (Mask_Width/2)，循环遍历掩码宽度时，通过if (N_start_point + j >= 0 && N_start_point + j < Width)判断输入索引是否合法。合法则累加N[N_start_point + j]*M[j]，否则跳过（等价于幽灵细胞值为0），确保边界输出元素计算符合卷积定义。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存对稀疏矩阵向量乘法（SpMV）有何优化作用？",
    "reference": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "prediction": "SpMV中同一行的非零元素可能被重复访问（如多向量乘法），或相邻行的非零元素存储位置相近，L2缓存可缓存这些数据，减少全局内存访问。GPU架构中L2缓存为所有SM共享，容量较大（如数十MB），能有效提升数据复用率，降低SpMV的内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过线程块维度设置提升并行效率？",
    "reference": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "prediction": "线程块维度需匹配GPU架构特性，通常设置为32的倍数（如16×16、32×8），确保warp利用率。例如16×16线程块（256线程），每个SM可调度多个块（如Fermi架构SM可调度6个256线程块），最大化SM的线程并行度，同时避免线程块过小导致的调度开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，线程块的TILE_SIZE选择需考虑哪些GPU架构限制？",
    "reference": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "prediction": "需考虑SM的共享内存容量，TILE_SIZE越大，共享内存数组（如N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]）占用空间越多。例如Maxwell架构SM有48KB共享内存，若TILE_SIZE=64、MAX_MASK_WIDTH=9，共享内存占用（64+8）×4=288字节，远低于限制；若TILE_SIZE过大导致共享内存溢出，会触发编译错误或运行时异常。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SIMD硬件如何提升ConvNets卷积层的计算吞吐量？",
    "reference": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "prediction": "ConvNets卷积层的线程执行相同的乘法累加指令，GPU的SIMD硬件（warp执行模式）让32个线程同时执行一条指令，大幅提升计算并行度。例如处理3×3卷积时，同一warp内线程对不同输入元素执行相同的卷积核乘法，SIMD硬件可批量处理这些操作，提升指令执行吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过填充优化（Padding）提升内存访问效率？",
    "reference": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "prediction": "针对CSR格式的行偏移数组csrRowPtr，按GPU内存访问对齐要求（如32字节）进行填充，确保线程访问时能触发合并访问。例如将csrRowPtr数组的长度填充为32的倍数，避免因数组长度不足导致的非合并访问，减少内存事务数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽瓶颈为何对矩阵乘法算子影响显著？",
    "reference": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "prediction": "基础矩阵乘法算子的计算/全局内存访问比低（约1:1），即每执行1次浮点运算需1次全局内存访问。GPU的全局内存带宽有限（如1TB/s），当算子受限于内存带宽时，即使计算资源未饱和，性能也无法提升。通过tiling优化提升数据复用率，可缓解带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何使用自动变量（寄存器）提升计算速度？",
    "reference": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "prediction": "将累加结果（如Pvalue）声明为自动变量，CUDA编译器会将其分配到寄存器，避免使用全局内存或共享内存存储中间结果。例如float Pvalue = 0; for (int j = 0; j < Mask_Width; j++) { Pvalue += ...; }，寄存器的低延迟特性可加速累加计算，减少内存访问开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM多线程调度如何隐藏矩阵乘法算子的内存延迟？",
    "reference": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "prediction": "矩阵乘法算子访问全局内存时存在数百周期延迟，SM通过调度多个线程块（如8个）的warp，当一个warp等待内存时，调度其他就绪warp执行计算。例如Fermi架构SM可同时跟踪1536个线程，通过多warp切换，让GPU计算资源持续工作，掩盖内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子如何将2D输入线性化以适配全局内存存储？",
    "reference": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i]，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "prediction": "采用行优先（row-major）布局，将2D坐标（row, col）转换为线性索引row * pitch + col，其中pitch为每行的字节数（含填充）。例如N_ds[ty][tx] = data[row_i * pitch + col_i，确保2D输入的连续行在全局内存中连续存储，便于触发合并访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存缓存对卷积核访问有何优化？",
    "reference": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "prediction": "常量内存缓存为只读缓存，支持广播访问，当卷积算子的所有线程访问同一卷积核元素时，GPU只需从全局内存加载一次，通过缓存广播到所有线程。例如3×3卷积核的中心元素被所有线程访问，常量内存缓存可大幅减少该元素的全局内存访问次数，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的线程块大小选择需匹配哪些GPU架构参数？",
    "reference": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "prediction": "需匹配SM的最大线程数（如Fermi架构1536线程/SM）和最大块数（如8块/SM）。例如选择256线程/块，SM可同时调度6块（6×256=1536线程），充分利用SM资源；若选择512线程/块，SM仅能调度3块，可能导致并行度不足。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过边界检查处理非TILE_WIDTH倍数的矩阵？",
    "reference": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH=256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "prediction": "在 kernel 中添加if ((Row < Width) && (Col < Width))判断，仅当线程映射的矩阵元素索引合法时才执行计算。例如矩阵宽度为1000、TILE_WIDTH为256，最后一个线程块的部分线程索引超出矩阵范围，通过边界检查跳过无效计算，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存带宽比全局内存高多少，对卷积算子有何意义？",
    "reference": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "prediction": "GPU共享内存带宽通常是全局内存的10-100倍（如Volta架构共享内存带宽约1TB/s，全局内存约900GB/s，实际访问延迟更低）。卷积算子通过将邻域输入加载到共享内存，让多次访问转为高带宽的共享内存访问，大幅提升数据访问速度，突破全局内存带宽瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何复用前向传播的中间数据？",
    "reference": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "prediction": "前向传播时将卷积层的输入、特征图等数据存储在全局内存或共享内存中，反向传播时直接访问这些数据，避免重复计算或重新加载。例如前向传播的特征图feature_map存储在全局内存，反向传播计算梯度时通过feature_map[row * pitch + col]访问，减少数据冗余和内存开销。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp大小（32线程）如何影响卷积算子的线程块设计？",
    "reference": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "prediction": "线程块大小需为32的倍数，确保warp无空闲线程。例如设计128线程块（4个warp）、256线程块（8个warp），避免64线程块（2个warp但可能因边界处理导致warp divergence）。32线程的warp大小也要求卷积算子的线程映射尽量让相邻线程执行相同路径，减少分歧。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrVal数组，如何确保线程访问的合并性？",
    "reference": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "prediction": "让相邻线程访问csrVal数组的连续元素，例如线程块内线程按csrRowPtr[row] + threadIdx.x索引访问，当行内非零元素数量足够时，相邻线程的索引连续，触发全局内存合并访问，减少内存事务，提升访问效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，__syncthreads()的作用是什么？",
    "reference": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "prediction": "用于线程块内线程同步，确保所有线程完成共享内存加载后再开始计算。例如在加载Mds和Nds共享内存数组后调用__syncthreads()，避免部分线程未加载完成就读取共享内存，导致数据错误，是tiling优化的关键同步手段。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多通道内存（如GDDR6）如何提升矩阵乘法算子的带宽？",
    "reference": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "prediction": "多通道内存通过多个独立内存通道并行传输数据，例如GDDR6有8个通道，每个通道带宽达100GB/s，总带宽达800GB/s。矩阵乘法算子需大量输入输出数据传输，多通道内存提供的高带宽的满足数据传输需求，避免带宽成为性能瓶颈。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的掩码（Mask）存储在常量内存的优势是什么？",
    "reference": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "prediction": "常量内存容量有限（64KB），适合存储小尺寸掩码；支持缓存和广播访问，所有线程访问同一掩码元素时仅需一次全局内存加载；减少掩码数据的全局内存访问次数，尤其适合掩码复用率高的卷积计算，提升整体性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM核心数如何影响ConvNets卷积层的计算速度？",
    "reference": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "prediction": "SM核心数越多（如A100有108个SM），并行计算资源越丰富，能同时调度更多线程块执行卷积计算。例如108个SM同时处理不同的特征图区域，大幅提升卷积层的计算吞吐量，缩短执行时间。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理行数远大于线程块数的稀疏矩阵？",
    "reference": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "prediction": "通过blockIdx.x循环分配线程块到矩阵行，例如int row = blockIdx.x * blockDim.y + threadIdx.y，让多个线程块并行处理不同行，即使矩阵有数十万行，也能通过多线程块扩展并行度，充分利用GPU资源。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，TILE_WIDTH选择为16或32的依据是什么？",
    "reference": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "prediction": "依据GPU架构的共享内存容量和warp大小，16×16 tile的共享内存占用为（16×16×4）×2=2048字节，32×32 tile为（32×32×4）×2=8192字节，均在SM共享内存限制内；同时16、32是warp大小（32）的因数，便于线程映射和warp调度，减少warp divergence。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存对齐要求如何影响卷积算子的输入数据存储？",
    "reference": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "prediction": "GPU全局内存访问要求数据起始地址对齐到32字节或64字节，否则会触发额外内存事务。卷积算子的输入数据需按此要求存储，例如通过cudaMallocPitch分配内存，确保每行起始地址对齐，线程访问时能触发合并访问，提升内存效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何处理多通道输入（如RGB图像）？",
    "reference": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "prediction": "每个线程处理一个通道的元素，或通过循环遍历所有通道，例如for (int c = 0; c < channels; c++) { Pvalue += x[c][row][col] * w[c][k][l]; }，将多通道输入的每个通道与卷积核对应通道相乘后累加，得到最终输出元素，确保多通道卷积的计算正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存对矩阵乘法算子的tiling优化有何补充？",
    "reference": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "prediction": "L1缓存为每个SM私有，容量较小（如16KB），可缓存共享内存未覆盖的高频访问数据。矩阵乘法算子的tiling优化主要依赖共享内存，L1缓存可缓存全局内存加载到共享内存的中间数据，或共享内存溢出的数据，进一步减少全局内存访问，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrColInd数组，为何需要与csrVal数组一一对应？",
    "reference": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "prediction": "csrColInd存储每个非零元素的列索引，csrVal存储对应非零元素的值，线程通过int col = csrColInd[csrRowPtr[row] + idx]; float val = csrVal[csrRowPtr[row] + idx];获取列索引和值，完成与向量元素的乘法（sum += val * vec[col]），一一对应关系是SpMV计算正确性的基础。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，如何通过循环展开提升指令执行效率？",
    "reference": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "prediction": "对掩码遍历循环（for (int j = 0; j < Mask_Width; j++)）进行展开，例如手动展开3×3卷积的9次迭代，或使用#pragma unroll指令让编译器自动展开，减少循环控制指令开销，同时让编译器优化指令调度，提升指令级并行度。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的功耗限制如何影响卷积算子的性能调优？",
    "reference": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "prediction": "高功耗场景下，GPU会降低核心频率，导致计算吞吐量下降。卷积算子调优需平衡并行度和功耗，例如选择合适的线程块大小（避免过度并行导致功耗过高），优化内存访问（减少高功耗的全局内存访问），确保在功耗限制内最大化性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Pvalue累加变量为何要声明为volatile？",
    "reference": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "prediction": "仅在特殊场景下（如多线程修改同一变量）需要，通常无需声明。若矩阵乘法算子中存在线程间数据依赖（如非tiled优化的特殊实现），volatile可防止编译器优化掉必要的内存访问，确保变量值的正确性；常规tiled实现中，Pvalue为线程私有，无需volatile。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的异步执行如何提升SpMV算子的整体吞吐量？",
    "reference": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "prediction": "GPU支持异步内存传输和内核执行，SpMV算子可采用“数据传输-内核执行”重叠模式，例如通过cudaStream创建流，在一个流执行内核时，另一个流传输下一批数据，隐藏数据传输延迟，提升整体吞吐量，尤其适合处理大规模稀疏矩阵。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中1D卷积算子的输出数组P，如何分配全局内存以避免内存碎片？",
    "reference": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "prediction": "使用cudaMalloc分配连续的全局内存，避免频繁分配释放小内存块；根据输出数组大小（Width×sizeof(float)）一次性分配足够空间，确保内存地址连续，便于线程合并访问，同时减少内存碎片对性能的影响。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的共享内存bank冲突如何在SpMV算子中避免？",
    "reference": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "prediction": "SpMV算子的共享内存访问通常为行内连续访问，通过调整共享内存数组的维度（如添加填充字节），让相邻线程访问不同bank。例如__shared__ float sdata[TILE_SIZE + 1]，通过+1填充避免同一warp内线程访问同一bank，确保并行访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的反向传播算子，如何计算卷积核的梯度？",
    "reference": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "prediction": "基于链式法则，将输出梯度作为输入，与前向传播的输入特征图进行交叉相关计算，得到卷积核的梯度。例如dW[k][c][l][k] += sum(dY[row][col] * X[row + l][col + k])，通过线程映射让每个线程计算卷积核一个元素的梯度，并行完成梯度更新。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的计算能力（如Compute Capability 8.6）对矩阵乘法算子有何影响？",
    "reference": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "prediction": "更高计算能力支持更多硬件特性，如更大的共享内存容量、更优的合并访问规则、张量核心（Tensor Cores）。例如Compute Capability 8.0+支持Tensor Cores，矩阵乘法算子可通过wmma API调用Tensor Cores，实现混合精度计算，大幅提升吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何处理空行（无非零元素的矩阵行）？",
    "reference": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则线程跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "prediction": "通过csrRowPtr数组判断行是否为空（if (csrRowPtr[row+1] == csrRowPtr[row])），若为空则线程跳过该行列的计算，直接输出0或不更新结果，避免无效的内存访问和计算，提升算子效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaMemcpyToSymbol的作用是什么？",
    "reference": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "prediction": "用于将主机端的卷积核（掩码）数据复制到设备端的常量内存数组。例如cudaMemcpyToSymbol(M, M_h, Mask_Width*sizeof(float))，将主机的M_h数组复制到设备的__constant__ float M[]，让内核高效访问卷积核数据，避免重复的全局内存加载。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存控制器数量如何影响SpMV算子的带宽？",
    "reference": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "prediction": "内存控制器数量越多，GPU可同时处理的内存请求越多，总带宽越高。SpMV算子的内存访问具有随机性，更多内存控制器能分散请求压力，减少内存冲突，提升有效带宽，尤其适合非合并访问场景。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的线程块维度（如dim3(16,16)）为何选择二维？",
    "reference": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "prediction": "二维线程块更贴合矩阵的二维结构，线程索引（threadIdx.x, threadIdx.y）可直接映射到矩阵的列和行，简化索引计算（如Row = by * TILE_WIDTH + ty; Col = bx * TILE_WIDTH + tx）；同时二维线程块便于处理二维数据的tiling，提升代码可读性和维护性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的warp调度器如何选择就绪warp执行？",
    "reference": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已加载完成的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "prediction": "warp调度器优先选择无数据依赖、已获取所需数据的warp执行。矩阵乘法算子中，当一个warp等待共享内存加载时，调度器会选择其他已加载完成的warp执行计算，最大化SM的计算资源利用率，隐藏内存延迟。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中2D卷积算子的halo细胞加载，如何避免线程冗余计算？",
    "reference": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "prediction": "仅让部分线程加载halo细胞，例如左halo由线程块的最后n个线程加载（if (threadIdx.x >= blockDim.x - n)），右halo由前n个线程加载（if (threadIdx.x < n)），核心细胞由所有线程加载，避免所有线程都尝试加载halo细胞导致的冗余计算和内存访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的常量内存容量限制（64KB）如何影响ConvNets的大尺寸卷积核？",
    "reference": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "prediction": "大尺寸卷积核（如11×11）的元素数量可能超过64KB（如11×11×3×64=23232字节，未超限制；更大核可能超），此时需将卷积核存储在全局内存，通过tiling加载到共享内存，或分块处理卷积核，每次加载部分核元素到共享内存，再与输入数据计算。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的输出向量初始化为何要使用cudaMemset？",
    "reference": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "prediction": "确保输出向量的初始值为0，避免未初始化的垃圾值影响计算结果。例如cudaMemset(d_y, 0, n*sizeof(float))，将设备端输出向量d_y初始化为0，之后SpMV算子的线程累加计算结果到d_y，确保结果正确性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何通过blockDim和gridDim计算总线程数？",
    "reference": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "prediction": "总线程数=gridDim.x × gridDim.y × blockDim.x × blockDim.y。例如gridDim(ceil(Width/16), ceil(Width/16))、blockDim(16,16)，总线程数=ceil(Width/16)×ceil(Width/16)×256，确保总线程数覆盖所有矩阵元素。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L2缓存一致性对多SM执行SpMV算子有何意义？",
    "reference": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "prediction": "L2缓存一致性确保多个SM访问同一内存地址时获取最新值，SpMV算子若存在多SM修改同一输出向量元素（如稀疏矩阵多行映射到同一输出元素），L2缓存一致性可避免数据竞争，确保累加结果正确，无需额外同步机制。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中卷积算子的__shared__变量声明为何要指定大小？",
    "reference": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "prediction": "共享内存是线程块私有内存，编译时需确定大小以分配硬件资源。例如__shared__ float N_ds[TILE_SIZE + MAX_MASK_WIDTH - 1]，指定大小后编译器会预留对应共享内存空间，避免运行时动态分配的开销和不确定性，确保线程块内线程正常访问。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的张量核心（Tensor Cores）如何提升ConvNets卷积层性能？",
    "reference": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "prediction": "Tensor Cores专门优化矩阵乘法累加（GEMM）操作，支持混合精度计算（如FP16输入、FP32累加）。ConvNets卷积层可转换为GEMM操作（如im2col转换），通过调用Tensor Cores，每时钟周期可执行更多乘法累加操作，大幅提升卷积计算吞吐量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的csrRowPtr数组为何要比矩阵行数多1？",
    "reference": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "prediction": "csrRowPtr[row]表示第row行非零元素的起始索引，csrRowPtr[row+1]表示结束索引，行数+1的长度可覆盖最后一行的结束索引。例如n行矩阵的csrRowPtr长度为n+1，通过csrRowPtr[row+1] - csrRowPtr[row]可快速获取第row行的非零元素数量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA矩阵乘法算子中，如何处理浮点数溢出？",
    "reference": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "prediction": "可使用混合精度计算（如FP16/FP32），或在累加时添加溢出检查（如if (Pvalue > FLT_MAX) Pvalue = FLT_MAX;）；现代GPU支持IEEE浮点数标准，溢出时会自动处理为无穷大或NaN，也可通过编译器选项启用溢出检测，确保计算稳定性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的内存带宽与计算吞吐量的比例（如1TB/s带宽、10TFLOPS计算）如何影响卷积算子？",
    "reference": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "prediction": "该比例决定算子是内存绑定还是计算绑定。卷积算子的计算/内存访问比若低于比例（如1:1 < 10TFLOPS/1TB/s=10），则为内存绑定，需通过tiling、共享内存优化提升数据复用；若高于比例，则为计算绑定，需优化指令执行效率（如循环展开、Tensor Cores）。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何实现零填充（Zero Padding）？",
    "reference": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "prediction": "在计算输入索引时，若索引超出输入边界（row < 0 || row >= height || col < 0 || col >= width），则输入值视为0，否则访问实际输入数据。例如float x_val = (row >=0 && row < height && col >=0 && col < width) ? x[row*pitch + col] : 0.0f，实现零填充功能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的SM调度器如何分配线程块到SM？",
    "reference": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "prediction": "SM调度器根据SM的空闲资源（寄存器、共享内存、线程槽）分配线程块，遵循负载均衡原则。矩阵乘法算子的线程块大小一致，调度器可均匀分配线程块到所有SM，确保所有SM都处于忙碌状态，提升GPU整体利用率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子如何通过线程私有化提升性能？",
    "reference": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "prediction": "将行内非零元素的累加结果存储在线程私有变量（寄存器）中，完成行内所有非零元素计算后，再将结果写入全局内存。例如float sum = 0; for (int idx = 0; idx < nnz_per_row; idx++) { sum += csrVal[...]; } d_y[row] = sum;，减少全局内存写操作次数，提升性能。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA卷积算子中，cudaGetDeviceProperties的作用是什么？",
    "reference": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "prediction": "获取GPU设备的硬件特性（如共享内存容量、最大线程块大小、计算能力）。例如通过dev_prop.sharedMemPerBlock获取每个SM的共享内存容量，动态调整TILE_SIZE和Mask_Width，确保算子适配不同GPU设备，提升代码可移植性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的多进程并发对SpMV算子有何影响？",
    "reference": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "prediction": "多进程并发会共享GPU资源（SM、内存带宽），若多个进程同时执行SpMV算子，每个进程的可用资源减少，性能下降。可通过CUDA流和资源限制（如cudaSetDeviceFlags）优化并发执行，确保进程间资源隔离，减少相互干扰。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中矩阵乘法算子的Nds[ty][tx] = N[(ph*TILE_WIDTH + ty)*Width + Col]索引计算的含义是什么？",
    "reference": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "prediction": "将N矩阵的子矩阵加载到共享内存Nds，ph为相位索引（遍历所有子矩阵），ph*TILE_WIDTH + ty是N矩阵的行索引，Col是列索引，通过该计算获取当前相位下N矩阵子矩阵的元素，存储到共享内存，为后续乘法累加做准备。",
    "rougeL_f1": 1.0
  },
  {
    "question": "GPU架构的L1缓存写回策略对卷积算子有何影响？",
    "reference": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "prediction": "L1缓存写回策略（如写回、写透）决定数据何时写入L2缓存。卷积算子的输出数据通常为顺序写，写回策略可减少L1到L2的写操作次数，提升写带宽；若为随机写，写透策略可避免数据丢失，确保数据一致性，需根据访问模式选择。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中SpMV算子的__device__函数作用是什么？",
    "reference": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "prediction": "__device__函数是设备端函数，仅能被内核或其他__device__函数调用，用于封装SpMV的重复计算逻辑（如非零元素乘法累加）。例如__device__ float spmv_row(float* csrVal, int* csrColInd, float* vec, int start, int end)，内核调用该函数处理一行的计算，提升代码复用性。",
    "rougeL_f1": 1.0
  },
  {
    "question": "CUDA中ConvNets的卷积层算子，如何通过im2col转换提升性能？",
    "reference": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "prediction": "im2col将卷积操作转换为矩阵乘法，即将输入特征图的每个卷积窗口展开为矩阵的一列，卷积核展开为矩阵的一行，通过GEMM完成卷积计算。例如3×3卷积的im2col转换后，调用CUDA的GEMM内核，利用矩阵乘法的tiling优化和Tensor Cores，提升卷积性能。\n二、适中题（17道，算法+CUDA编程）",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA编程，tiled矩阵乘法算子如何通过数据复用提升计算/内存访问比？",
    "reference": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累加 ... }。",
    "prediction": "算法上采用分块（tiling）将大矩阵划分为小尺寸子矩阵（如16×16），确保子矩阵可放入共享内存；CUDA编程中，线程块协作加载子矩阵到Mds和Nds共享内存，每个子矩阵元素被TILE_WIDTH次复用（如16×16子矩阵的每个元素参与16次乘法累加）。原本基础算法的计算/内存访问比为1:1，tiled优化后提升至TILE_WIDTH:1（如16:1），大幅缓解内存带宽瓶颈，核心代码为嵌套循环for (int ph = 0; ph < Width/TILE_WIDTH; ++ph) { ... 加载子矩阵 ... 乘法累",
    "rougeL_f1": 1.0
  },
  {
    "question": "算法层面如何优化SpMV算子的负载均衡，CUDA编程如何实现该优化？",
    "reference": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "prediction": "算法上采用行分组策略，将非零元素数量相近的行分配到同一线程块，避免部分线程块处理大量非零元素、部分线程块处理少量元素导致的负载不均；CUDA编程中，通过预处理矩阵行，按非零元素数量排序，再通过blockIdx.x映射线程块到行组，线程块内线程按行内非零元素索引分配任务，核心逻辑为int row_group = blockIdx.x; int start_row = group_start[row_group]; int end_row = group_end[row_group];，确保各线程块工作量均衡。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，2D卷积算子如何通过分块大小选择平衡共享内存占用与并行度？",
    "reference": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "prediction": "算法上，分块大小（TILE_SIZE）需兼顾共享内存容量和数据复用率，TILE_SIZE越大，数据复用率越高，但共享内存占用越多，并行度越低；CUDA编程中，通过cudaGetDeviceProperties获取共享内存容量，动态计算最优TILE_SIZE（如TILE_SIZE = sqrt(dev_prop.sharedMemPerBlock / sizeof(float) - MAX_MASK_WIDTH + 1)），确保共享内存不溢出，同时通过dim3 gridDim(ceil(width/TILE_SIZE), ceil(height/TILE_SIZE))设置线程块数量，平衡并行度与内存优化，核心代码需包含TILE_SIZE动态计算和线程块配置。",
    "rougeL_f1": 1.0
  },
  {
    "question": "ConvNets的卷积层算法如何转换为矩阵乘法，CUDA编程如何高效实现该转换？",
    "reference": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y;\n    int channel = blockIdx.z;\n    if (row < height && col < width) {\n        int idx = channel * height * width + row * width + col;\n        // 展开卷积窗口到x_col\n        for (int k = 0; k < kernel_size; k++) {\n            for (int l = 0; l < kernel_size; l++) {\n                int x_row = row + k - kernel_size/2;\n                int x_col = col + l - kernel_size/2;\n                if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n                    x_col[col * kernel_sizekernel_size + kkernel_size + l] = x[channel * height * width + x_row * width + x_col];\n                }\n            }\n        }\n    }\n}\n之后调用GEMM内核完成矩阵乘法，利用矩阵乘法的优化特性提升卷积性能。",
    "prediction": "算法上通过im2col转换，将输入特征图的每个卷积窗口（如3×3）展开为矩阵的一列，卷积核展开为矩阵的一行，卷积计算转为矩阵乘法（GEMM）；CUDA编程中，先实现im2col内核，将输入特征图转换为矩阵格式（通过线程映射展开窗口），再调用优化的GEMM内核（如cuBLAS或自定义tiled GEMM），核心代码片段：\nglobal void im2col_kernel(float* x, float* x_col, int height, int width, int kernel_size) {\n    int col = blockIdx.x * blockDim.x + threadIdx.x;\n    int row = blockIdx.y * blockDim.y + threadIdx.y",
    "rougeL_f1": 0.5029940119760479
  },
  {
    "question": "算法层面如何处理稀疏矩阵的转置以优化SpMV算子，CUDA编程如何实现转置？",
    "reference": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_csrVal, int n) {\n    int row = blockIdx.x * blockDim.x + threadIdx.x;\n    if (row < n) {\n        for (int i = csrRowPtr[row]; i < csrRowPtr[row+1]; i++) {\n            int col = csrColInd[i];\n            float val = csrVal[i];\n            int pos = atomicAdd(&t_csrRowPtr[col+1], 1);\n            t_csrColInd[pos] = row;\n            t_csrVal[pos] = val;\n        }\n    }\n}\n转置后SpMV算子的内存访问更易合并，提升性能。",
    "prediction": "算法上，稀疏矩阵转置可改变非零元素的存储顺序，使SpMV算子的内存访问更连续（如列优先访问转为行优先）；CUDA编程中，基于CSR格式实现转置：1. 统计每行非零元素数量，初始化转置后的csrRowPtr；2. 分配转置后的csrColInd和csrVal；3. 线程块处理原矩阵每行，将非零元素（col, val）写入转置矩阵的col行，核心代码：\nglobal void csr_transpose_kernel(int* csrRowPtr, int* csrColInd, float* csrVal, int* t_csrRowPtr, int* t_csrColInd, float* t_c",
    "rougeL_f1": 0.5535714285714286
  },
  {
    "question": "结合算法与CUDA，矩阵乘法算子如何通过循环展开提升指令吞吐量？",
    "reference": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE_WIDTH较大的场景。",
    "prediction": "算法上，对乘法累加循环（for (int k = 0; k < TILE_WIDTH; ++k)）进行展开，减少循环控制指令开销，同时暴露指令级并行；CUDA编程中，使用#pragma unroll指令让编译器自动展开，或手动展开循环（如展开为4次迭代），核心代码：\n#pragma unroll 4\nfor (int k = 0; k < TILE_WIDTH; ++k) {\n    Pvalue += Mds[ty][k] * Nds[k][tx];\n}\n编译器可优化指令调度，让乘法和累加指令并行执行，同时减少循环变量递增和条件判断的开销，提升指令执行吞吐量，尤其适合TILE",
    "rougeL_f1": 0.9841269841269841
  },
  {
    "question": "卷积算子的算法如何通过“ halo 细胞复用”减少数据传输，CUDA编程如何实现？",
    "reference": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "prediction": "算法上，相邻线程块的halo细胞存在重叠（如块0的右halo是块1的左halo），通过缓存halo细胞避免重复加载；CUDA编程中，使用共享内存或L1缓存缓存halo细胞，例如块0加载右halo后，块1通过缓存访问该数据，无需重新从全局内存加载，核心代码需配合cudaDeviceSetCacheConfig设置缓存配置，确保halo细胞被缓存，减少全局内存传输量。",
    "rougeL_f1": 1.0
  },
  {
    "question": "SpMV算子的算法如何通过“行合并”优化，CUDA编程如何实现该优化？",
    "reference": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "prediction": "算法上，将相邻的多行（非零元素数量少）合并为一个超行，由一个线程块处理，减少线程块调度开销；CUDA编程中，预处理时将多行合并，更新csrRowPtr数组（超行的起始和结束索引），线程块按超行分配任务，每个线程处理超行内的非零元素，核心逻辑为int super_row = blockIdx.x; int start = super_csrRowPtr[super_row]; int end = super_csrRowPtr[super_row+1];，减少线程块数量，提升调度效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的反向传播算子如何优化梯度计算的内存访问？",
    "reference": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] += dY_ds[ty][tx] * X_ds[ty][tx];\n通过共享内存优化内存局部性，减少全局内存访问，提升梯度计算速度。",
    "prediction": "算法上，梯度计算的输入（输出梯度、前向特征图）存在空间局部性，采用分块处理，确保数据访问连续；CUDA编程中，使用tiling技术将输入数据加载到共享内存，线程块内线程协作计算梯度，核心代码：\nshared float dY_ds[TILE_SIZE][TILE_SIZE];\nshared float X_ds[TILE_SIZE][TILE_SIZE];\n// 加载输出梯度和前向特征图到共享内存\ndY_ds[ty][tx] = dY[row*pitch + col];\nX_ds[ty][tx] = X[(row + k)*pitch + (col + l)];\n__syncthreads();\n// 计算梯度\ndW[k][l] +=",
    "rougeL_f1": 0.9090909090909091
  },
  {
    "question": "矩阵乘法算子的算法如何处理非正方形矩阵，CUDA编程如何调整线程映射？",
    "reference": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0; k < K; k += TILE_K) {\n        // 加载矩形子矩阵\n        Mds[ty][tk] = M[Row*K + k + tk];\n        Nds[tk][tx] = N[(k + tk)N + Col];\n        __syncthreads();\n        // 乘法累加\n        for (int tk = 0; tk < TILE_K; tk++) {\n            Pvalue += Mds[ty][tk] * Nds[tk][tx];\n        }\n    }\n    P[RowN + Col] = Pvalue;\n}\n适配非正方形矩阵的维度，确保计算正确性和性能。",
    "prediction": "算法上，将非正方形矩阵（如M×K、K×N）划分为矩形子矩阵（如16×16、16×8），确保子矩阵适配共享内存；CUDA编程中，调整线程块维度（如dim3(16,8)）和索引计算，Row = by * blockDim.y + ty（覆盖M行），Col = bx * blockDim.x + tx（覆盖N列），k循环遍历K维子矩阵，核心代码：\nint Row = blockIdx.y * blockDim.y + threadIdx.y;\nint Col = blockIdx.x * blockDim.x + threadIdx.x;\nif (Row < M && Col < N) {\n    float Pvalue = 0;\n    for (int k = 0;",
    "rougeL_f1": 0.7248322147651006
  },
  {
    "question": "卷积算子的算法如何通过“多尺度分块”优化，CUDA编程如何实现？",
    "reference": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, width, height, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH - 1]），适配不同输入尺度。",
    "prediction": "算法上，根据输入尺寸和掩码大小动态调整分块尺度（如小输入用小TILE_SIZE，大输入用大TILE_SIZE），平衡并行度和内存复用；CUDA编程中，通过主机端计算不同尺度的TILE_SIZE，传递给内核作为参数，核心代码：\nint TILE_SIZE = (width < 256) ? 16 : 32;\nconv_kernel<<<gridDim, dim3(TILE_SIZE, TILE_SIZE)>>>(d_X, d_W, d_Y, width, height, TILE_SIZE);\n内核中根据TILE_SIZE调整共享内存数组大小（如__shared__ float X_ds[TILE_SIZE + MAX_MASK_WIDTH - 1][TILE_SIZE + MAX_MASK_WIDTH -",
    "rougeL_f1": 0.98989898989899
  },
  {
    "question": "SpMV算子的算法如何通过“原子操作优化”处理输出向量的累加，CUDA编程如何实现？",
    "reference": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "prediction": "算法上，当多个线程需累加同一输出向量元素时（如多行当量映射到同一列），使用原子操作确保数据一致性；CUDA编程中，使用atomicAdd函数实现原子累加，核心代码：\nint col = csrColInd[i];\nfloat val = csrVal[i] * vec[col];\natomicAdd(&d_y[row], val);\n同时优化原子操作的访问模式，让原子操作集中在同一缓存行，减少缓存冲突，提升原子操作效率。",
    "rougeL_f1": 1.0
  },
  {
    "question": "结合算法与CUDA，ConvNets的卷积层算子如何优化多通道输入的计算？",
    "reference": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size + l];\n    }\n}\nY[row * width + col] += Pvalue;\n通过三维线程块（gridDim.z=channels）并行处理多通道，提升计算效率。",
    "prediction": "算法上，将多通道输入的每个通道与卷积核对应通道相乘后累加，采用通道并行处理；CUDA编程中，线程块按通道分组，每个线程处理一个通道的计算，核心代码：\nint channel = blockIdx.z;\nint row = blockIdx.y * blockDim.y + threadIdx.y;\nint col = blockIdx.x * blockDim.x + threadIdx.x;\nfloat Pvalue = 0;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        Pvalue += X[channel * height * width + (row + k) * width + (col + l)] * W[channel * kernel_size * kernel_size + k * kernel_size",
    "rougeL_f1": 0.9291338582677166
  },
  {
    "question": "矩阵乘法算子的算法如何通过“预取”优化内存访问，CUDA编程如何实现？",
    "reference": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next_ph*TILE_WIDTH + ty)*Width + Col];\n    }\n    __syncthreads();\n    // 计算当前子矩阵\n    for (int k = 0; k < TILE_WIDTH; ++k) {\n        Pvalue += Mds0[ty][k] * Nds0[k][tx];\n    }\n    // 切换缓冲\n    swap(Mds0, Mds1);\n    swap(Nds0, Nds1);\n}\n通过计算与预取重叠，减少内存延迟对性能的影响。",
    "prediction": "算法上，提前加载下一个子矩阵到共享内存，与当前子矩阵的计算重叠，隐藏内存加载延迟；CUDA编程中，使用双缓冲技术，设置两组共享内存（Mds0/Mds1、Nds0/Nds1），一组用于当前计算，另一组预取下一子矩阵，核心代码：\nfor (int ph = 0; ph < Width/TILE_WIDTH; ++ph) {\n    // 预取下一子矩阵\n    if (ph < Width/TILE_WIDTH - 1) {\n        int next_ph = ph + 1;\n        Mds1[ty][tx] = M[RowWidth + next_phTILE_WIDTH + tx];\n        Nds1[ty][tx] = N[(next",
    "rougeL_f1": 0.7358490566037735
  },
  {
    "question": "卷积算子的算法如何处理“空洞卷积”（Dilated Convolution），CUDA编程如何调整索引计算？",
    "reference": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width) {\n            Pvalue += X[x_rowpitch + x_col] * W[kkernel_size + l];\n        }\n    }\n}\n通过k*dilation和l*dilation跳过空洞位置，实现空洞卷积的计算逻辑。",
    "prediction": "算法上，空洞卷积通过在卷积核元素间插入空洞（零），扩大感受野，计算时需跳过空洞位置；CUDA编程中，调整输入索引计算，加入空洞率（dilation rate）参数，核心代码：\nint dilation = 2;\nfor (int k = 0; k < kernel_size; k++) {\n    for (int l = 0; l < kernel_size; l++) {\n        int x_row = row + k * dilation - (kernel_size-1)dilation/2;\n        int x_col = col + l * dilation - (kernel_size-1)dilation/2;\n        if (x_row >=0 && x_row < height && x_col >=0 && x_col < width",
    "rougeL_f1": 0.890625
  }
]